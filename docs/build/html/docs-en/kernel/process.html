
<!DOCTYPE html>

<html lang="y">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Process &#8212; Harmony 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="process">
<h1>Process<a class="headerlink" href="#process" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-concepts">
<h2>Basic Concepts<a class="headerlink" href="#basic-concepts" title="Permalink to this headline">¶</a></h2>
<p>Processes are resource management units in the OS. They can use or wait
to use CPUs and use system resources such as memory. They run
independently from one another.</p>
<p>The OpenHarmony kernel allows multiple processes to run simultaneously,
switch, and communicate, facilitating your management over service
programs. In this regard, you will have more time to devote to the
implementation of service functionalities.</p>
<p>Processes in the OpenHarmony kernel use the preemptive scheduling
mechanism, either round-robin (RR) scheduling or First In First Out
(FIFO) scheduling.</p>
<p>These processes are assigned 32 priorities (<strong>0</strong> to <strong>31</strong>). Among
them, user processes can be configured with 22 priorities from <strong>10</strong>
(highest) to <strong>31</strong> (lowest).</p>
<p>A high-priority process can preempt the resources of a low-priority
process. The low-priority process can be scheduled only after the
high-priority process is blocked or terminated.</p>
<p>Each user-space process has its own memory space, which is invisible to
other processes. In this way, processes are isolated from each other.</p>
<p>The user-space root process init is started by the kernel. Then other
user-space processes are created by the init process via the <strong>fork</strong>
call.</p>
<p><strong>A process may have the following states:</strong></p>
<ul class="simple">
<li><p><strong>Init</strong>: The process is being created.</p></li>
<li><p><strong>Ready</strong>: The process is in the ready list and waits for being
scheduled by the CPU.</p></li>
<li><p><strong>Running</strong>: The process is running.</p></li>
<li><p><strong>Pend</strong>: The process is blocked and suspended. When all threads in a
process are blocked, the process is blocked and suspended.</p></li>
<li><p><strong>Zombies</strong>: The process stops running and waits for the parent
process to reclaim its control block resources.</p></li>
</ul>
<p><strong>Figure 1</strong> State transition of a process</p>
<p><img alt="image1" src="../../_images/en-us_image_0000001053930456.png" /></p>
<p><strong>Description of the process state transition:</strong></p>
<ul>
<li><p>Init→Ready:</p>
<p>When a process is created, the process enters the <strong>Init</strong> state to
start initialization after obtaining the process control block. After
the process is initialized, the process is inserted into the
scheduling queue and therefore enters the <strong>Ready</strong> state.</p>
</li>
<li><p>Ready→Running:</p>
<p>When a process switchover is triggered, the process with the highest
priority in the ready list is executed and enters the <strong>Running</strong>
state. If this process has no thread in the <strong>Ready</strong> state, the
process is deleted from the ready list and resides only in the
<strong>Running</strong> state. However, if it has threads in the <strong>Ready</strong> state,
the process still stays in the ready list. In this case, the process
is in both the <strong>Ready</strong> and <strong>Running</strong> states.</p>
</li>
<li><p>Running→Pend:</p>
<p>If all threads in a process are entering the <strong>Pend</strong> state, the
process will enter the <strong>Pend</strong> state together with its last thread.
Then, a process switchover is triggered.</p>
</li>
<li><p>Pend→Ready/Pend→Running:</p>
<p>When any thread in a <strong>Pend</strong> process restores to the <strong>Ready</strong>
state, the process is added to the ready list and changes to the
<strong>Ready</strong> state. If a process switchover occurs at this time, the
process state changes from the <strong>Ready</strong> state to the <strong>Running</strong>
state.</p>
</li>
<li><p>Ready→Pend:</p>
<p>When the last ready thread in a process enters the <strong>Pend</strong> state,
the process is deleted from the ready list, and the process changes
from the <strong>Ready</strong> state to the <strong>Pend</strong> state.</p>
</li>
<li><p>Running→Ready:</p>
<p>A process may change from the <strong>Running</strong> state to the <strong>Ready</strong>
state in either of the following scenarios:</p>
<ol class="arabic simple">
<li><p>After a process with a higher priority is created or restored,
processes will be scheduled. The process with the highest priority
in the ready list will change to the <strong>Running</strong> state, and the
originally running process will change from the <strong>Running</strong> state
to the <strong>Ready</strong> state.</p></li>
<li><p>If a process has the <strong>SCHED_RR</strong> scheduling policy and shares the
same priority with another process in the <strong>Ready</strong> state, this
process will change from the <strong>Running</strong> state to the <strong>Ready</strong>
state after its time slices are used up, and the other process
with the same priority will change from the <strong>Ready</strong> state to the
<strong>Running</strong> state.</p></li>
</ol>
</li>
<li><p>Running→Zombies:</p>
<p>After the main thread or all threads of a process are stopped, the
process changes from the <strong>Running</strong> state to the <strong>Zombies</strong> state
and waits for the parent process to reclaim resources.</p>
</li>
</ul>
</div>
<div class="section" id="when-to-use">
<h2>When to Use<a class="headerlink" href="#when-to-use" title="Permalink to this headline">¶</a></h2>
<p>After processes are created, you can operate the resources only in your
own process space, except shared resources. In user space, processes can
be suspended, restored, and delayed. In addition, you can set and obtain
the scheduling priority and scheduling policy of processes. When a
process is terminated, it proactively releases its resources. However,
the PID resources of the process are reclaimed by the parent process via
<strong>wait</strong>/<strong>waitpid</strong> or when the parent process exits.</p>
</div>
<div class="section" id="available-apis">
<h2>Available APIs<a class="headerlink" href="#available-apis" title="Permalink to this headline">¶</a></h2>
<p>The following table describes the APIs provided by the process
management module of the OpenHarmony kernel.</p>
<p><strong>Table 1</strong> APIs provided by the process management module</p>
<table><thead align="left"><tr id="row630210427446"><th class="cellrowborder" valign="top" width="13.020000000000001%" id="mcps1.2.5.1.1"><p id="p1430244284410"><p>Category</p>
</p></th><th class="cellrowborder" valign="top" width="23.150000000000002%" id="mcps1.2.5.1.2"><p id="p9302164284416"><p>Function</p>
</p></th><th class="cellrowborder" valign="top" width="28.93%" id="mcps1.2.5.1.3"><p id="p730211427445"><p>Description</p>
</p></th><th class="cellrowborder" valign="top" width="34.9%" id="mcps1.2.5.1.4"><p id="p1430214294419"><p>Remarks</p>
</p></th></tr></thead><tbody><tr id="row12302642134414"><td class="cellrowborder" rowspan="13" valign="top" width="13.020000000000001%" headers="mcps1.2.5.1.1 "><p id="p430213427443"><p>Process</p>
</p></td><td class="cellrowborder" valign="top" width="23.150000000000002%" headers="mcps1.2.5.1.2 "><p id="p10302154219449"><p>fork</p>
</p></td><td class="cellrowborder" valign="top" width="28.93%" headers="mcps1.2.5.1.3 "><p id="p930218420449"><p>Creates a new process.</p>
</p></td><td class="cellrowborder" valign="top" width="34.9%" headers="mcps1.2.5.1.4 "><p id="p230224211440"><p>N/A</p>
</p></td></tr><tr id="row20302154218442"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p130314204419"><p>exit</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p53031426443"><p>Exits the process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p113034423445"><p>N/A</p>
</p></td></tr><tr id="row930314421443"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p13303124213442"><p>atexit</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p1330324210442"><p>Registers the callback that will be called when the process is
terminated normally.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p3303144264414"><p>N/A</p>
</p></td></tr><tr id="row113039426449"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1630394220444"><p>abort</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p133037421441"><p>Terminates the process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p1330334216449"><p>N/A</p>
</p></td></tr><tr id="row1330317422445"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p113036427441"><p>getpid</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p17303642194412"><p>Obtains the process ID.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p14304942104420"><p>N/A</p>
</p></td></tr><tr id="row3304204254412"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1430404218442"><p>getppid</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p9304134217443"><p>Obtains the parent process ID.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p1530418423449"><p>N/A</p>
</p></td></tr><tr id="row610863618327"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p110811368324"><p>getpgrp</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p51091436133217"><p>Obtains the ID of the process group of the calling process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p31094364326"><p>N/A</p>
</p></td></tr><tr id="row2379940183217"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1380184016329"><p>getpgid</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p8121101872215"><p>Obtains the process group ID of the process identified by pid.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p63802401326"><p>N/A</p>
</p></td></tr><tr id="row1981395963412"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p4814559123412"><p>setpgrp</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p171226183225"><p>Sets the process group ID of the calling process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p8814959123416"><p>N/A</p>
</p></td></tr><tr id="row194862793516"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p5948162703511"><p>setpgid</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p7122131852218"><p>Sets the process group ID of the process identified by pid.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p1994915279352"><p>N/A</p>
</p></td></tr><tr id="row10304742114410"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p530474264418"><p>kill</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p2304174213441"><p>Sends a signal to a specified process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><ul id="ul949915272011"><li><p>Only signals 1 to 30 can be sent.</p>
</li><li><p>The default behavior for signals does not include STOP and CONTINUE and
terminates the process without a core dump.</p>
</li><li><p>SIGSTOP, SIGKILL, and SIGCONT cannot be masked.</p>
</li><li><p>After an asynchronous signal is sent to a process, the signal callback
is invoked only after the process is scheduled. For the sake of
security, the process can be killed only by itself, and the kernel
cannot forcibly kill the process by sending signals.</p>
</li><li><p>After the process is killed, SIGCHLD is sent to its parent process. The
sending action cannot be canceled.</p>
</li><li><p>A sleeping process cannot be woken up by a signal.</p>
</li></ul></td></tr><tr id="row1430454210446"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p830494212443"><p>wait</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p230464294410"><p>Waits for any child process to terminate and reclaims its resources.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p12512337347"><p>The status value is defined by the following macros:</p>
</p><ul id="ul13349201524417"><li><p>WIFEXITED(status): If the child process terminates normally, true is
returned. Otherwise, false is returned.</p>
</li><li><p>WEXITSTATUS(status): If WIFEXITED(status) is true, this macro can be
used to obtain the exit code that the child process passed to exit().</p>
</li><li><p>WTERMSIG(status): If a child process terminates abnormally, the child
process exit code obtained by the parent process through WTERMSIG is
always SIGUSR2. This is the only case supported.</p>
</li><li><p>The following operations are not supported: WIFSTOPPED, WSTOPSIG,
WCOREDUMP, and WIFCONTINUED.</p>
</li></ul></td></tr><tr id="row13041742134416"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1530434217444"><p>waitpid</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p130564294420"><p>Waits for a specified child process to terminate and reclaims its
resources.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p969785263816"><p>The options to control the function behavior do not support WUNTRACED
and WCONTINUED.</p>
</p><p id="p8497151543715"><p>The status value is defined by the following macros:</p>
</p><ul id="ul7243133164416"><li><p>WIFEXITED(status): If the child process terminates normally, true is
returned. Otherwise, false is returned.</p>
</li><li><p>WEXITSTATUS(status): If WIFEXITED(status) is true, this macro can be
used to obtain the exit code that the child process passed to exit().</p>
</li><li><p>WTERMSIG(status): If a child process terminates abnormally, the child
process exit code obtained by the parent process through WTERMSIG is
always SIGUSR2. This is the only case supported.</p>
</li><li><p>The following operations are not supported: WIFSTOPPED, WSTOPSIG,
WCOREDUMP, and WIFCONTINUED.</p>
</li></ul></td></tr><tr id="row4305194294417"><td class="cellrowborder" rowspan="10" valign="top" width="13.020000000000001%" headers="mcps1.2.5.1.1 "><p id="p5305194264419"><p>Scheduling</p>
</p></td><td class="cellrowborder" valign="top" width="23.150000000000002%" headers="mcps1.2.5.1.2 "><p id="p630544224416"><p>getpriority</p>
</p></td><td class="cellrowborder" valign="top" width="28.93%" headers="mcps1.2.5.1.3 "><p id="p174915589591"><p>Obtains the static priority of a specified ID.</p>
</p></td><td class="cellrowborder" rowspan="2" valign="top" width="34.9%" headers="mcps1.2.5.1.4 "><ul id="ul185518513478"><li><p>PRIO_PGRP and PRIO_USER are not supported.</p>
</li></ul><ul id="ul85091358174711"><li><p>The priority to obtain and set refers to the static priority. The
dynamic priority is not involved.</p>
</li></ul></td></tr><tr id="row930511425448"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1730524217448"><p>setpriority</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p17750205817594"><p>Sets the static priority of a specified ID.</p>
</p></td></tr><tr id="row2305174216445"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p7305942104417"><p>sched_rr_get_interval</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p1362018100165"><p>Obtains the execution time limit of a process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p5306134212447"><p>N/A</p>
</p></td></tr><tr id="row33061042104416"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p143061642164412"><p>sched_yield</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p1262017102164"><p>Yields the running process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p14306134220441"><p>N/A</p>
</p></td></tr><tr id="row11306134234417"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p11306184264417"><p>sched_get_priority_max</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p123062423446"><p>Obtains the maximum static priority that can be used for a process.</p>
</p></td><td class="cellrowborder" rowspan="4" valign="top" headers="mcps1.2.5.1.3 "><p id="p11306154210440"><p>The scheduling policy can only be SCHED_FIFO or SCHED_RR.</p>
</p></td></tr><tr id="row15306242124413"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p430612427448"><p>sched_get_priority_min</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p430618428442"><p>Obtains the minimum static priority that can be used for a process.</p>
</p></td></tr><tr id="row730610428448"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p230684284419"><p>sched_getscheduler</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p20306184224417"><p>Obtains the scheduling policy of a process.</p>
</p></td></tr><tr id="row630764215441"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1530719424444"><p>sched_setscheduler</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p13072042104416"><p>Sets a scheduling policy for a process.</p>
</p></td></tr><tr id="row3307184274411"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p12307114274419"><p>sched_getparam</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p9307104210441"><p>Obtains scheduling parameters of a process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p163071842194417"><p>N/A</p>
</p></td></tr><tr id="row18307104210449"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1230784264419"><p>sched_setparam</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p1530784215445"><p>Sets scheduling parameters related to a scheduling policy for a process.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p730714264415"><p>N/A</p>
</p></td></tr><tr id="row17412918306"><td class="cellrowborder" rowspan="6" valign="top" width="13.020000000000001%" headers="mcps1.2.5.1.1 "><p id="p8528162314312"><p>exec</p>
</p></td><td class="cellrowborder" valign="top" width="23.150000000000002%" headers="mcps1.2.5.1.2 "><p id="p1951498305"><p>execl</p>
</p></td><td class="cellrowborder" valign="top" width="28.93%" headers="mcps1.2.5.1.3 "><p id="p1612191842215"><p>Executes a specified user program file in ELF format.</p>
</p></td><td class="cellrowborder" valign="top" width="34.9%" headers="mcps1.2.5.1.4 "><p id="p11679610113215"><p>N/A</p>
</p></td></tr><tr id="row16964151163015"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p1996413117300"><p>execle</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p104059331261"><p>Executes a specified user program file in ELF format.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p3209101117329"><p>N/A</p>
</p></td></tr><tr id="row9418101418309"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p741881443010"><p>execlp</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p493315383264"><p>Executes a specified user program file in ELF format.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p8741121112325"><p>N/A</p>
</p></td></tr><tr id="row2058611176305"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p155869170309"><p>execv</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p1644334112613"><p>Executes a specified user program file in ELF format.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p423311211323"><p>N/A</p>
</p></td></tr><tr id="row182359476306"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p202351547163016"><p>execve</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p13152444192616"><p>Executes a specified user program file in ELF format.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p148072123324"><p>N/A</p>
</p></td></tr><tr id="row14242145013304"><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.1 "><p id="p02437507305"><p>execvp</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.2 "><p id="p06334469262"><p>Executes a specified user program file in ELF format.</p>
</p></td><td class="cellrowborder" valign="top" headers="mcps1.2.5.1.3 "><p id="p333161353217"><p>N/A</p>
</p></td></tr></tbody></table></div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Harmony</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Arul.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/docs-en/kernel/process.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>