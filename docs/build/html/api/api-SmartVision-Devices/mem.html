
<!DOCTYPE html>

<html lang="y">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MEM &#8212; Harmony 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="mem">
<h1>MEM<a class="headerlink" href="#mem" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2><strong>Overview</strong><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Provides structures and functions for performing memory operations,
including memory mapping, remapping, allocation, and release.</p>
<p><strong>Since:</strong></p>
<p>1.0</p>
<p><strong>Version:</strong></p>
<p>1.0</p>
</div>
<div class="section" id="summary">
<h2><strong>Summary</strong><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="files">
<h2>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h2>
<table><thead align="left"><tr id="row812054874084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1176194672084824"><p>File Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p237173750084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1234744111084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1886291998084824"><p>malloc.h</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p203346041084824"><p>Declares APIs for allocating and releasing memory.</p>
</p></td></tr><tr id="row1855116454084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p953517973084824"><p>mman.h</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p249160126084824"><p>Declares structures and functions for performing memory operations,
including memory mapping, remapping, unmapping, and attribute setting.</p>
</p></td></tr><tr id="row146440572084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1913839936084824"><p>shm.h</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2075740579084824"><p>Declares APIs for creating, mapping, deleting, and controlling shared
memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<table><thead align="left"><tr id="row37238497084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p667676610084824"><p>Data Structure Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1368063596084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row254907990084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p493779893084824"><p>shmid_ds</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p769695349084824"><p>Stores information about a shared memory segment.</p>
</p></td></tr><tr id="row737618268084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p779043113084824"><p>shminfo</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p222047412084824"><p>Describes limitations and attributes of system-level shared memory.</p>
</p></td></tr><tr id="row1689909426084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p602669859084824"><p>shm_info</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p817611295084824"><p>Describes system resource information about the shared memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h2>
<table><thead align="left"><tr id="row904468166084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p259380612084824"><p>Macro Name and Value</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p123102738084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1217528099084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p686751702084824"><p>MAP_FAILED ((void *) -1)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p813956620084824"><p>Indicates the return value of functions such as mmap() when the
operation fails.</p>
</p></td></tr><tr id="row1155901719084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1628198086084824"><p>MAP_SHARED 0x01</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1312725240084824"><p>Indicates the mapping attribute that the updates to the mapping are
visible to other processes mapping the same file and are carried through
to the underlying file. This macro is used as an input parameter passed
to functions such as mmap().</p>
</p></td></tr><tr id="row171292457084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p110869228084824"><p>MAP_PRIVATE 0x02</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1831566688084824"><p>Indicates the mapping attribute that the updates to the mapping are not
visible to other mapping processes and are not carried through to the
underlying file. This macro is used as an input parameter passed to
functions such as mmap().</p>
</p></td></tr><tr id="row283700836084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1217118486084824"><p>MAP_FIXED 0x10</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p202663715084824"><p>Indicates the mapping attribute that specifies the mapping as fixed
mapping. This macro is used as an input parameter passed to functions
such as mmap().</p>
</p></td></tr><tr id="row1152706215084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1790530733084824"><p>MAP_ANON 0x20</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p113876264084824"><p>Indicates the mapping attribute that specifies the mapping as anonymous
mapping without a specified file or device. This macro is used as an
input parameter passed to functions such as mmap().</p>
</p></td></tr><tr id="row496723867084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1057244533084824"><p>MAP_ANONYMOUS MAP_ANON</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p452837994084824"><p>Indicates the mapping attribute that specifies the mapping as anonymous
mapping without a specified file or device. This macro is the synonym
for MAP_ANON and is used as an input parameter passed to functions such
as mmap().</p>
</p></td></tr><tr id="row1208280650084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1994298883084824"><p>PROT_NONE 0</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1285556738084824"><p>Indicates that no permission is granted to the current process for
accessing the mapping area. This macro is used as an input parameter
passed to functions such as mmap().</p>
</p></td></tr><tr id="row1892021657084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p564958388084824"><p>PROT_READ 1</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2099248122084824"><p>Indicates that the current process is granted the read permission on the
mapping area. This macro is used as an input parameter passed to
functions such as mmap().</p>
</p></td></tr><tr id="row799451010084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2035791855084824"><p>PROT_WRITE 2</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p379231642084824"><p>Indicates that the current process is granted the write permission on
the mapping area. This macro is used as an input parameter passed to
functions such as mmap().</p>
</p></td></tr><tr id="row344191521084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1141227585084824"><p>PROT_EXEC 4</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p115269167084824"><p>Indicates that the current process is granted the execute permission on
the mapping area. This macro is used as an input parameter passed to
functions such as mmap().</p>
</p></td></tr><tr id="row1997647191084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p826672210084824"><p>MREMAP_MAYMOVE 1</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p415280211084824"><p>Indicates the remapping attribute that allows the mapping to be
relocated to a new address. This macro is used as an input parameter
passed to functions such as mremap().</p>
</p></td></tr><tr id="row600577389084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1222512667084824"><p>MREMAP_FIXED 2</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p280614889084824"><p>Indicates the remapping attribute that specifies the mapping as fixed
mapping. This macro is used as an input parameter passed to functions
such as mremap().</p>
</p></td></tr><tr id="row1795418818084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1492692620084824"><p>SHMLBA 4096</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1300108811084824"><p>Aligns the shared memory address.</p>
</p></td></tr><tr id="row883742196084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p602452957084824"><p>SHM_R 0400</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p716552610084824"><p>Indicates that the shared memory segment is readable. This macro is used
for setting the shmflg parameter passed to functions such as shmget().</p>
</p></td></tr><tr id="row969298200084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p500143069084824"><p>SHM_W 0200</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p631673564084824"><p>Indicates that the shared memory segment is writable. This macro is used
for setting the shmflg parameter passed to functions such as shmget().</p>
</p></td></tr><tr id="row201278404084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p928782338084824"><p>SHM_RDONLY 010000</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1695870039084824"><p>Indicates that the attached shared memory segment is read-only. This
macro is used for setting the shmflg parameter passed to functions such
as shmat().</p>
</p></td></tr><tr id="row1598989737084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1823408773084824"><p>SHM_RND 020000</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p266221626084824"><p>Indicates that the shared memory address can be rounded to a value
meeting the requirement (SHMLBA). This macro is used for setting the
shmflg parameter passed to functions such as shmat().</p>
</p></td></tr><tr id="row1336770385084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p846848077084824"><p>SHM_REMAP 040000</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1165752233084824"><p>Indicates that the memory segment can be remapped. This macro is used
for setting the shmflg parameter passed to functions such as shmat().</p>
</p></td></tr><tr id="row997724144084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1789536740084824"><p>SHM_EXEC 0100000</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1881394756084824"><p>Indicates that the attached shared memory segment is executable. This
macro is used for setting the shmflg parameter passed to functions such
as shmat().</p>
</p></td></tr><tr id="row1622545381084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p187132236084824"><p>SHM_LOCK 11</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p459018319084824"><p>Locks the shared memory segment in memory so that it cannot be swapped
to the swap partition. This macro is used for setting the shmflg
parameter passed to functions such as shmget().</p>
</p></td></tr><tr id="row65753657084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1492007486084824"><p>SHM_UNLOCK 12</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2073791768084824"><p>Unlocks the shared memory segment. This macro is used for setting the
shmflg parameter passed to functions such as shmget().</p>
</p></td></tr><tr id="row286805282084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1105407811084824"><p>SHM_STAT (13 | (IPC_STAT &amp; 0x100))</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1084486519084824"><p>Obtains a shmid_ds data structure. This macro is used for setting the
cmd parameter passed to shmctl().</p>
</p></td></tr><tr id="row1884143605084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1887695189084824"><p>SHM_INFO 14</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1245245073084824"><p>Obtains a shm_info data structure that includes system resource
information about this shared memory segment. This macro is used for
setting the cmd parameter passed to shmctl().</p>
</p></td></tr><tr id="row792425190084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p863320888084824"><p>SHM_STAT_ANY (15 | (IPC_STAT &amp; 0x100))</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2013360895084824"><p>Obtains a shmid_ds data structure without permission check. This macro
is used for setting the cmd parameter passed to shmctl().</p>
</p></td></tr></tbody></table></div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<table><thead align="left"><tr id="row2052783631084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1900732467084824"><p>Function Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p271361051084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row579056829084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1839963165084824"><p>malloc (size_t size)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p993506918084824"><p>void *</p>
</p><p id="p1172603532084824"><p>Dynamically allocates a block of uninitialized memory with the specified
size.</p>
</p></td></tr><tr id="row13445151084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1780562578084824"><p>calloc (size_t nmemb, size_t size)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p84905273084824"><p>void *</p>
</p><p id="p1066402207084824"><p>Dynamically allocates multiple blocks of memory with the specified size.</p>
</p></td></tr><tr id="row1992768405084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p365227171084824"><p>realloc (void *ptr, size_t size)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p820721363084824"><p>void *</p>
</p><p id="p141385858084824"><p>Changes the size of a previously allocated memory block pointed to by
ptr to the specified size.</p>
</p></td></tr><tr id="row1086360258084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p939809720084824"><p>free (void *ptr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1307063373084824"><p>void</p>
</p><p id="p2029703656084824"><p>Frees the memory space pointed to by ptr.</p>
</p></td></tr><tr id="row242462086084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p102463813084824"><p>memalign (size_t alignment, size_t size)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p185181806084824"><p>void *</p>
</p><p id="p1094074856084824"><p>Allocates a block of memory with the specified size based on the given
alignment mode.</p>
</p></td></tr><tr id="row130733337084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p108351048084824"><p>malloc_usable_size (void *ptr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p143183122084824"><p>size_t</p>
</p><p id="p199485075084824"><p>Obtains the size of the memory block pointed to by ptr.</p>
</p></td></tr><tr id="row1970887887084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p422121597084824"><p>mmap (void *addr, size_t length, int prot, int flags, int fd, off_t
offset)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1883703622084824"><p>void *</p>
</p><p id="p759717593084824"><p>Creates a mapping between the virtual address space of the calling
process and a file or device.</p>
</p></td></tr><tr id="row337149447084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p49725344084824"><p>munmap (void *addr, size_t length)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p539013459084824"><p>int</p>
</p><p id="p1353683996084824"><p>Removes all mappings for the specified virtual address space.</p>
</p></td></tr><tr id="row1477818312084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1838024203084824"><p>mprotect (void *addr, size_t len, int prot)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1094849500084824"><p>int</p>
</p><p id="p93283869084824"><p>Sets protection attributes for the memory pages contained in the memory
region starting from addr with the specified length.</p>
</p></td></tr><tr id="row1154156168084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1761564105084824"><p>mremap (void *old_address, size_t old_size, size_t new_size, int
flags,…)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1449500648084824"><p>void *</p>
</p><p id="p649142230084824"><p>Remaps a virtual memory region.</p>
</p></td></tr><tr id="row2141309199084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1262609606084824"><p>shmat (int shmid, const void *shmaddr, int shmflg)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p976720260084824"><p>void *</p>
</p><p id="p1926212822084824"><p>Attaches the shared memory segment identified by shmid to the address
space of the current process.</p>
</p></td></tr><tr id="row225393781084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p911715133084824"><p>shmctl (int shmid, int cmd, struct shmid_ds *buf)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1694841363084824"><p>int</p>
</p><p id="p1178613392084824"><p>Performs a control operation specified by the cmd parameter on the
shared memory segment identified by shmid.</p>
</p></td></tr><tr id="row1527687719084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1296603742084824"><p>shmdt (const void *shmaddr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p315516445084824"><p>int</p>
</p><p id="p1264346188084824"><p>Detaches the shared memory segment attached to the address pointed to by
shmaddr from the address space of the calling process.</p>
</p></td></tr><tr id="row437380008084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p603932087084824"><p>shmget (key_t key, size_t size, int shmflg)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1523639761084824"><p>int</p>
</p><p id="p877905428084824"><p>Obtains or creates a shared memory segment with the specified size based
on the ID specified by key.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="details">
<h2><strong>Details</strong><a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="function-documentation">
<h2><strong>Function Documentation</strong><a class="headerlink" href="#function-documentation" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="calloc">
<h2>calloc()<a class="headerlink" href="#calloc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">calloc</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Dynamically allocates multiple blocks of memory with the specified size.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row833258820084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p429510752084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1503647998084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1108543622084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>nmemb</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the number of memory blocks to allocate.</p>
</td></tr><tr id="row751353480084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the size of the memory block to allocate, in bytes.</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the pointer to the allocated memory block if the operation is
successful; returns <strong>NULL</strong> and sets <strong>errno</strong> to a value in the
following table if the operation fails or <strong>nmemb</strong> or <strong>size</strong> is set
to <strong>0</strong>.</p>
<table><thead align="left"><tr id="row1909779098084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1076719282084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p620611015084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1816389185084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1511006443084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p654115894084824"><p>Insufficient memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="free">
<h2>free()<a class="headerlink" href="#free" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">free</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Frees the memory space pointed to by <strong>ptr</strong>.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1428417629084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p2098287643084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1240993057084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row786158824084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>ptr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to a memory block previously allocated with
malloc, calloc or realloc.</p>
</td></tr></tbody></table></div>
<div class="section" id="malloc">
<h2>malloc()<a class="headerlink" href="#malloc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Dynamically allocates a block of uninitialized memory with the specified
size.</p>
<p>The allocated memory can be initialized by calling
<a class="reference external" href="utils.md#gace6ee45c30e71865e6eb635200379db9">memset()</a>.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row2105847914084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p876525735084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1952229998084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row313102975084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the size of the memory block to allocate, in bytes.</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the pointer to the allocated memory block if the operation is
successful; returns <strong>NULL</strong> and sets <strong>errno</strong> to a value in the
following table if the operation fails or <strong>size</strong> is set to <strong>0</strong>.</p>
<table><thead align="left"><tr id="row400900894084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p872494485084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p972866424084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row991326776084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p126078823084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p468080182084824"><p>Insufficient memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="malloc-usable-size">
<h2>malloc_usable_size()<a class="headerlink" href="#malloc-usable-size" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">size_t</span> <span class="n">malloc_usable_size</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Obtains the size of the memory block pointed to by <strong>ptr</strong>.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row989859810084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1649976715084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p67369373084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row993174979084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>ptr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to a block of memory previously allocated by
functions such as malloc().</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the number of usable bytes in the block of allocated memory
pointed to by <strong>ptr</strong>; returns <strong>0</strong> if <strong>ptr</strong> is <strong>NULL</strong>.</p>
<p><strong>See also:</strong></p>
<p><a class="reference external" href="mem.md#ga7ac38fce3243a7dcf448301ee9ffd392">malloc()</a> |
<a class="reference external" href="mem.md#ga62b7798461bd461da64c5f9d35feddf7">calloc()</a> |
<a class="reference external" href="mem.md#ga1a6b5e8d2f1c37e5b43e4345586075be">realloc()</a></p>
</div>
<div class="section" id="memalign">
<h2>memalign()<a class="headerlink" href="#memalign" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">memalign</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Allocates a block of memory with the specified size based on the given
alignment mode.</p>
<p>The value of <strong>alignment</strong> must be a power of two.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row2105050070084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p374394890084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1149260371084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row398991037084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>alignment</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the alignment size of the allocated memory.</p>
</td></tr><tr id="row1620526765084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the size of the memory block to allocate, in bytes.</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the pointer to the allocated memory block if the operation is
successful; returns <strong>NULL</strong> and sets <strong>errno</strong> to a value in the
following table if the operation fails.</p>
<table><thead align="left"><tr id="row769074179084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p694285548084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1470104389084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row2071353038084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1601618055084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1602758482084824"><p>Invalid alignment value (not a power of two).</p>
</p></td></tr><tr id="row600253606084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p778301301084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1358029795084824"><p>Insufficient memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="mmap">
<h2>mmap()<a class="headerlink" href="#mmap" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">mmap</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="nb">int</span> <span class="n">prot</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Creates a mapping between the virtual address space of the calling
process and a file or device.</p>
<p>The start address for the mapping is specified by <strong>addr</strong>, and the
length to map is specified by <strong>length</strong>. The contents of the mapping
are initialized starting at <strong>offset</strong> with the specified <strong>length</strong> in
the file referred to by the file descriptor <strong>fd</strong>.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1144735203084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p41065528084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p416459231084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1123459131084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>addr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to the start address of the mapping. If this
parameter is NULL, the kernel determines the address to start.</p>
</td></tr><tr id="row1044286937084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>length</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the length of the mapping, in bytes.</p>
</td></tr><tr id="row804231312084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>prot</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the permission to be granted on the mapping area. The
permission to grant must not conflict with the open mode of the file.
The value of this parameter is the bitwise OR combination of one or more
of the following constants:</p>
</td></tr><tr id="row125352896084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>flags</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Specifies whether updates are visible to other processes mapping the
same segment, and whether updates are carried through to the underlying
file. The following table describes available values.</p>
</td></tr><tr id="row1136156585084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>fd</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the file or device to map.</p>
</td></tr><tr id="row2087112049084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>offset</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the offset into the file where the mapping will start.</p>
</td></tr></tbody></table><table><thead align="left"><tr id="row1900618505084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p71442180084824"><p>prot</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p738946941084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1236596454084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p704611308084824"><p>PROT_EXEC</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p982857856084824"><p>Executable</p>
</p></td></tr><tr id="row2068377492084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2094305164084824"><p>PROT_READ</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1994681800084824"><p>Readable</p>
</p></td></tr><tr id="row1552594768084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p82873017084824"><p>PROT_WRITE</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p718134410084824"><p>Writable</p>
</p></td></tr></tbody></table><p><strong>Attention:</strong></p>
<p>If the file mapping is successful, <strong>fd</strong> cannot be closed before the
mapping is deleted. (This rule does not conform to the Portable
Operating System Interface (POSIX) standard. You should pay special
attention to this rule.)</p>
<p><strong>Returns:</strong></p>
<p>Returns the pointer to the address where the mapping is placed if the
operation is successful; returns
<a class="reference external" href="mem.md#ga8523dcf952f6ff059a3bed717e4f1296">MAP_FAILED</a> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row1004790461084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p162440692084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p31516341084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1314902305084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1578428122084824"><p>EACCES</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p856722621084824"><p>The file descriptor specified by fd refers to a non-regular file. The
file descriptor specified by fd is invalid. MAP_SHARED and PROT_WRITE
are specified, but the file identified by fd is not opened in O_RDWR
mode. PROT_WRITE is specified, but the file is append-only.</p>
</p></td></tr><tr id="row2077208645084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1952556408084824"><p>EBADF</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p560535112084824"><p>The file descriptor specified by fd is invalid, and MAP_ANONYMOUS is not
specified in flags.</p>
</p></td></tr><tr id="row176716615084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1316943927084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1753914867084824"><p>The length and offset are too large, addr is not page-aligned, or the
length is 0. Neither MAP_SHARED nor MAP_ANONYMOUS is specified in flags,
or both are specified.</p>
</p></td></tr><tr id="row1535572417084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1601797353084824"><p>EAGAIN</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p735532956084824"><p>The file identified by fd has been locked.</p>
</p></td></tr><tr id="row924132953084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p896350896084824"><p>ENFILE</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2077074812084824"><p>The total number of open files exceeds the system limit.</p>
</p></td></tr><tr id="row1226746846084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1634184362084824"><p>ENODEV</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2018214059084824"><p>The file identified by fd does not support memory mapping.</p>
</p></td></tr><tr id="row1402815716084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p875725507084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1646097757084824"><p>Insufficient memory.</p>
</p></td></tr><tr id="row1262790967084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1826579547084824"><p>EPERM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1636609615084824"><p>PROT_EXEC is specified in prot, but the mapped area belongs to a file on
a file system that was mounted non-executable, or the file seal does not
allow this operation.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="mprotect">
<h2>mprotect()<a class="headerlink" href="#mprotect" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">mprotect</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">,</span> <span class="nb">int</span> <span class="n">prot</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Sets protection attributes for the memory pages contained in the memory
region starting from <strong>addr</strong> with the specified length.</p>
<p>The address specified by <strong>addr</strong> must be page-aligned. If the process
attempts to access memory in a manner that violates the protection
attributes, an access exception will occur, and the process will be
terminated.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row146751109084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1500697356084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1679724061084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row142387357084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>addr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to the start address of the memory region to
modify, which must be a multiple of the page size.</p>
</td></tr><tr id="row2053250008084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>len</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the length of the memory region to modify, in bytes.</p>
</td></tr><tr id="row2053527755084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>prot</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the permission of the memory region to modify, which can be a
bitwise OR combination of one or more of the constants listed in prot.</p>
</td></tr></tbody></table><table><thead align="left"><tr id="row528869870084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1507549702084824"><p>prot</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p95695648084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1711256671084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p725069733084824"><p>PROT_EXEC</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1877546880084824"><p>Executable</p>
</p></td></tr><tr id="row900880869084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1857641088084824"><p>PROT_READ</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p266914823084824"><p>Readable</p>
</p></td></tr><tr id="row500168876084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p361813991084824"><p>PROT_WRITE</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p44614840084824"><p>Writable</p>
</p></td></tr><tr id="row37722607084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1932735803084824"><p>PROT_NONE</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1584720201084824"><p>Not accessible</p>
</p></td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns <strong>0</strong> if the operation is successful; returns <strong>-1</strong> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row855231907084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1298390134084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1957511535084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row423287013084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1437697575084824"><p>EACCES</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p508245094084824"><p>The memory region cannot be granted the specified permission. This error
can occur, for example, when you use mmap to map a file with prot set to
PROT_READ and then use this function to set prot to PROT_WRITE.</p>
</p></td></tr><tr id="row2065474637084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p322692356084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p639129453084824"><p>addr is an invalid pointer or it points to an address that is not a
multiple of the page size.</p>
</p></td></tr><tr id="row396747212084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1958940402084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p309922732084824"><p>Internal kernel structures cannot be allocated due to insufficient
memory, or addresses in the specified range are invalid for the address
space of the process. The total number of mappings with different
attributes exceeds the maximum number allowed by the system if the
protection attribute of the memory region is changed.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="mremap">
<h2>mremap()<a class="headerlink" href="#mremap" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">mremap</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">old_address</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">new_size</span><span class="p">,</span> <span class="nb">int</span> <span class="n">flags</span><span class="p">,</span>  <span class="o">...</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Remaps a virtual memory region.</p>
<p>This function expands or shrinks an existing memory mapping, and may
also move the mapping at the same time depending on the settings of
<strong>flags</strong> and the available virtual address space.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1861704842084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p688509121084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1588232327084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1435662785084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>old_address</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the old address of the virtual memory region to expand or
shrink.</p>
</td></tr><tr id="row344935736084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>old_size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the old size of the virtual memory region.</p>
</td></tr><tr id="row54523210084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>new_size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the requested size of the virtual memory region after the
expansion or shrinking.</p>
</td></tr><tr id="row1067857587084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>flags</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Specifies whether the existing memory can be mapped to a new or
specified address.</p>
</td></tr><tr id="row1616238492084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>new_address</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the new address of the virtual memory region. This parameter
is optional and is used when MREMAP_FIXED is specified in flags.</p>
</td></tr></tbody></table><table><thead align="left"><tr id="row1086692365084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p981293482084824"><p>flags</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p339618865084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1715840691084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p866719931084824"><p>MREMAP_MAYMOVE</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p9285359084824"><p>By default, if no enough space is available to expand a mapping at its
current location, the operation fails. If this flag is specified, the
kernel is allowed to relocate the mapping to a new virtual address when
necessary.</p>
</p></td></tr><tr id="row883694804084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p123854790084824"><p>MREMAP_FIXED</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p621048489084824"><p>If this flag is specified, the new_address parameter is enabled in this
function and the memory is mapped to a new address. This flag must be
used together with MREMAP_MAYMOVE.</p>
</p></td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the pointer to the new mapping address if the operation is
successful; returns
<a class="reference external" href="mem.md#ga8523dcf952f6ff059a3bed717e4f1296">MAP_FAILED</a> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row1614664840084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p741837946084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1468225809084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1905722928084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1098215412084824"><p>EAGAIN</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1010236136084824"><p>The memory segment to expand is locked.</p>
</p></td></tr><tr id="row1631499122084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1831024344084824"><p>EFAULT</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p856658388084824"><p>Some memory addresses in the range from old_address to
old_address+old_size are invalid for this process.</p>
</p></td></tr><tr id="row1246163529084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p935530155084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2122862213084824"><p>old_address is not a multiple of the page size, or a value other than
MREMAP_MAYMOVE and MREMAP_FIXED is specified in flags. new_size is 0,
new_size or new_address is invalid, or MREMAP_FIXED is specified in
flags without also specifying MREMAP_MAYMOVE. old_size is 0 but
old_address does not point to a shared memory mapping; old_size is 0 but
MREMAP_MAYMOVE is not specified in flags; or the new memory address
range specified by new_address and new_size overlaps the old memory
address range specified by old_address and old_size.</p>
</p></td></tr><tr id="row1489241317084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p315703486084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1247293176084824"><p>Insufficient memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="munmap">
<h2>munmap()<a class="headerlink" href="#munmap" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">munmap</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Removes all mappings for the specified virtual address space.</p>
<p>After all mappings are removed, any references to addresses within the
specified range will generate invalid memory references. The memory
region will also be automatically unmapped when the process is
terminated. Closing the file descriptor does not remove mappings from
the region.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1834191158084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p950961674084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1161576643084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row563309834084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>addr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to the start address of the memory region to
unmap, which is the return value of mmap().</p>
</td></tr><tr id="row1244196673084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>length</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the length of the address range to unmap, which should be the
length specified in mmap().</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns <strong>0</strong> if the operation is successful; returns <strong>-1</strong> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row1051785061084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1142412152084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p111268583084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1409171310084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p498815665084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p311877936084824"><p>Invalid input parameters.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="realloc">
<h2>realloc()<a class="headerlink" href="#realloc" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">realloc</span> <span class="p">(</span><span class="n">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Changes the size of a previously allocated memory block pointed to by
<strong>ptr</strong> to the specified size.</p>
<p>The contents of the memory block will be retained from the beginning of
the memory pointed to by <strong>ptr</strong> to the lesser of the old and new sizes.
If the new size is larger than the old size, the added memory portion
will not be initialized. The behavior of this function varies depending
on the input parameters:</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1927656821084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1865161199084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p120360343084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1567265769084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>ptr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to a memory block previously allocated with
malloc, calloc or realloc.</p>
</td></tr><tr id="row2078597700084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the new size for the memory block, in bytes.</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the pointer to the new memory block if the operation is
successful; returns <strong>NULL</strong> and sets <strong>errno</strong> to a value in the
following table if the operation fails.</p>
<table><thead align="left"><tr id="row1334015417084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1890642150084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p7580352084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row2009088708084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p21956588084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p458648466084824"><p>Insufficient memory.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="shmat">
<h2>shmat()<a class="headerlink" href="#shmat" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">shmat</span> <span class="p">(</span><span class="nb">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span> <span class="n">shmaddr</span><span class="p">,</span> <span class="nb">int</span> <span class="n">shmflg</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Attaches the shared memory segment identified by <strong>shmid</strong> to the
address space of the current process.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row137299512084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p900208482084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1784764649084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row432690362084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>shmid</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Identifies the shared memory segment to attach, which is obtained by
shmget().</p>
</td></tr><tr id="row1119446237084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>shmaddr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the space address of the current process to attach. If this
parameter is NULL, the system chooses an unused address to attach.</p>
</td></tr><tr id="row1485293988084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>shmflg</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the attribute of the shared memory segment to attach, which is
the bitwise OR combination of one or more of the following flags:</p>
</td></tr></tbody></table><table><thead align="left"><tr id="row180017405084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1119586346084824"><p>shmflg</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1014878898084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1946813159084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1266293264084824"><p>SHM_RND</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1880368780084824"><p>Round the attached address. If shmaddr is not NULL and SHM_RND is
specified in shmflg, the address is rounded down to the nearest multiple
of SHMLBA.</p>
</p></td></tr><tr id="row1744650195084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p414410975084824"><p>SHM_EXEC</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p15429084084824"><p>Allow the contents of the attached shared memory segment to be
executable.</p>
</p></td></tr><tr id="row346224294084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p997725377084824"><p>SHM_RDONLY</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p53244286084824"><p>Set the contents of the attached shared memory segment to be read-only.</p>
</p></td></tr><tr id="row2035291885084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1025819348084824"><p>SHM_REMAP</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p868589381084824"><p>Replace any existing mapping in the address range starting at shmaddr
and continuing for the size of the segment during the current memory
mapping. When SHM_REMAP is not specified, an EINVAL error will be
returned if a mapping exists in the address range.</p>
</p></td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the pointer to the address of the attached shared memory segment
if the operation is successful; returns <strong>(void *)-1</strong> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row619339162084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p705682532084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1490230019084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row2121358743084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1786882567084824"><p>EACCES</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1105511137084824"><p>The current process does not have the required permission on the
requested mapping type.</p>
</p></td></tr><tr id="row834278449084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2123020549084824"><p>EIDRM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1076957489084824"><p>The shared memory segment specified by shmid has been removed.</p>
</p></td></tr><tr id="row993421793084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1027133495084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1322863348084824"><p>The value of shmid is invalid. shmaddr is not aligned (not page-aligned
and SHM_RND is not specified) or its value is invalid. SHM_REMAP is
specified, but shmaddr is NULL.</p>
</p></td></tr><tr id="row468066256084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p775175215084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1968392780084824"><p>No page tables can be allocated.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="shmctl">
<h2>shmctl()<a class="headerlink" href="#shmctl" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">shmctl</span> <span class="p">(</span><span class="nb">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">struct</span> <span class="p">[</span><span class="n">shmid_ds</span><span class="p">](</span><span class="n">shmid_ds</span><span class="o">.</span><span class="n">md</span><span class="p">)</span> <span class="o">*</span> <span class="n">buf</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Performs a control operation specified by the <strong>cmd</strong> parameter on the
shared memory segment identified by <strong>shmid</strong>.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row203572680084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p2030886541084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1170762244084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1416455454084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>shmid</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Identifies the shared memory segment to attach, which is obtained by
shmget().</p>
</td></tr><tr id="row1607732691084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>cmd</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the control operation to perform. The following table
describes available values.</p>
</td></tr><tr id="row1047251534084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>buf</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to the buffer for storing the information to set
or obtain.</p>
</td></tr></tbody></table><table><thead align="left"><tr id="row2092420991084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1727103972084824"><p>cmd</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1189504295084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row420247281084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1366084928084824"><p>IPC_STAT</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p897996284084824"><p>Copy information from the kernel data structure associated with the
shared memory segment identified by shmid into the shmid_ds structure
pointed to by buf.</p>
</p></td></tr><tr id="row12594795084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1463733136084824"><p>SHM_STAT</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p931957887084824"><p>Return a shmid_ds data structure. When SHM_STAT is specified, shmid does
not identify a shared memory segment. Instead, it indicates the index to
the kernel’s internal array that maintains information about all shared
memory segments.</p>
</p></td></tr><tr id="row914941770084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p69608613084824"><p>IPC_SET</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p181223418084824"><p>Write the values of some fields in the shmid_ds data structure pointed
to by buf to the kernel data structure associated with the specified
shared memory segment, updating also its shm_ctimemember. The following
fields can be modified: shm_perm.uid, shm_perm.gid, and shm_perm.mode.</p>
</p></td></tr><tr id="row1901568975084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1526696326084824"><p>IPC_RMID</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1288617317084824"><p>Mark the shared memory segment to be destroyed.</p>
</p></td></tr><tr id="row351995788084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p855640909084824"><p>IPC_INFO</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p666218134084824"><p>Return information about system-wide shared memory limits and parameters
in the structure pointed to by buf. The returned structure is of the
shminfo type, and a cast is required.</p>
</p></td></tr><tr id="row1749226637084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1086489666084824"><p>SHM_INFO</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1527888382084824"><p>Return a shm_info structure that contains information about system
resources consumed by the specified shared memory segment.</p>
</p></td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns <strong>0</strong> if the operation is successful; returns <strong>-1</strong> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row242553002084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p700427241084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p2092083090084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row992073766084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1325758842084824"><p>EACCES</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1775292264084824"><p>IPC_STAT or SHM_STAT is specified in cmb, but the mode field in shm_perm
does not allow any read operation on the shared memory segment
identified by shmid.</p>
</p></td></tr><tr id="row1675851456084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p442158682084824"><p>EFAULT</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2142526176084824"><p>SHM_STAT or IPC_STAT is specified in cmd, but the address pointed to by
buf is not accessible.</p>
</p></td></tr><tr id="row1631515084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p203026992084824"><p>EIDRM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2089393110084824"><p>shmid points to a removed shared memory segment.</p>
</p></td></tr><tr id="row1882413797084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p907473414084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p214203822084824"><p>The value of shmid or cmd is invalid. When SHM_STAT is specified in cmd,
the value is considered invalid if the index specified by shmid refers
to an unused array slot.</p>
</p></td></tr><tr id="row1288045442084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1090958587084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p693285326084824"><p>No page tables can be allocated.</p>
</p></td></tr><tr id="row628512434084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p723634282084824"><p>EPERM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1127982496084824"><p>IPC_SET or IPC_RMID is attempted, but the effective user ID of the
calling process is not that of the creator or the owner, and the process
is not privileged.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="shmdt">
<h2>shmdt()<a class="headerlink" href="#shmdt" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">shmdt</span> <span class="p">(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span> <span class="n">shmaddr</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Detaches the shared memory segment attached to the address pointed to by
<strong>shmaddr</strong> from the address space of the calling process.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1449119520084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1791656116084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p2084220491084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row499600790084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>shmaddr</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the pointer to the address of the shared memory segment to
detach. The value of this parameter should be the pointer previously
returned by shmat().</p>
</td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns <strong>0</strong> if the operation is successful; returns <strong>-1</strong> and sets
<strong>errno</strong> to a value in the following table if the operation fails.</p>
<table><thead align="left"><tr id="row750779876084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p873966071084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p745276177084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1784720307084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1766917195084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1289743491084824"><p>No shared memory segment is attached to shmaddr, or shmaddr is not
aligned.</p>
</p></td></tr></tbody></table></div>
<div class="section" id="shmget">
<h2>shmget()<a class="headerlink" href="#shmget" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">shmget</span> <span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="nb">int</span> <span class="n">shmflg</span> <span class="p">)</span>
</pre></div>
</div>
<p><strong>Description:</strong></p>
<p>Obtains or creates a shared memory segment with the specified size based
on the ID specified by <strong>key</strong>.</p>
<p>If the shared memory segment associated with <strong>key</strong> does not exist and
<a class="reference external" href="ipc.md#gace43f23fcb66ddaad964bb8ea8de6e9c">IPC_CREAT</a> is specified
in <strong>shmflg</strong> or if <strong>key</strong> has the value
<a class="reference external" href="ipc.md#gae2b9b856a4a657c250b0b2e1cc0835d9">IPC_PRIVATE</a>, this
function creates a shared memory segment with the size equal to the
value of <strong>size</strong> rounded up to a multiple of
<a class="reference external" href="utils.md#ga7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a>.</p>
<p><strong>Parameters:</strong></p>
<table><thead align="left"><tr id="row1546324133084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p448576925084824"><p>Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1391873123084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row2073671516084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>key</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the key of the shared memory segment.</p>
</td></tr><tr id="row782211243084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>size</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the size of the shared memory segment to create. The actual
size is rounded up to a multiple of PAGE_SIZE.</p>
</td></tr><tr id="row1254519898084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p>shmflg</p>
</td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p>Indicates the attribute of the shared memory segment, which is the
bitwise OR combination of one or more of the following flags:</p>
</td></tr></tbody></table><table><thead align="left"><tr id="row245435762084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1101811589084824"><p>shmflg</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p511403142084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1505603362084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1733409120084824"><p>IPC_CREAT</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1924494101084824"><p>Create a new shared memory segment. If this flag is not specified, this
function will find the segment with the specified key and check to see
whether the user has permission to access the segment.</p>
</p></td></tr><tr id="row1154408837084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p264321520084824"><p>IPC_EXCL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1147857429084824"><p>Used together with IPC_CREAT to ensure that this function is called to
create a shared memory segment. The calling fails if the segment already
exists.</p>
</p></td></tr></tbody></table><p><strong>Returns:</strong></p>
<p>Returns the ID of the shared memory segment if the operation is
successful; returns <strong>-1</strong> and sets <strong>errno</strong> to a value in the
following table if the operation fails.</p>
<table><thead align="left"><tr id="row1404302415084824"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1939772463084824"><p>errno</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p88608708084824"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row578746256084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1662803927084824"><p>EACCES</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1853521139084824"><p>The current process does not have the permission to obtain the specified
shared memory segment.</p>
</p></td></tr><tr id="row376957746084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p987413098084824"><p>EEXIST</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1727493393084824"><p>IPC_EXCL and IPC_CREAT are specified, but the shared memory segment
associated with key already exists.</p>
</p></td></tr><tr id="row2145732965084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1758140397084824"><p>EINVAL</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p372581242084824"><p>The size specified for the shared memory segment to create is less than
the value of shmmin in shminfo or greater than the value of shmmax. The
shared memory segment associated with key already exists, but the value
of size is greater than the size of the segment.</p>
</p></td></tr><tr id="row778798498084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p664794931084824"><p>ENOENT</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1749360377084824"><p>No segment exists for the given key, and IPC_CREAT is not specified.</p>
</p></td></tr><tr id="row1318905123084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1265998852084824"><p>ENOMEM</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1374577057084824"><p>Insufficient memory.</p>
</p></td></tr><tr id="row366353494084824"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1600318062084824"><p>ENOSPC</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1217902305084824"><p>Allocating a segment of the requested size would cause the system to
exceed the system-wide limit on shared memory (shmall in shminfo).</p>
</p></td></tr></tbody></table></div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Harmony</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Arul.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/api/api-SmartVision-Devices/mem.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>