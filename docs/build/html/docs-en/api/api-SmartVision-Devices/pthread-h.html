
<!DOCTYPE html>

<html lang="y">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pthread.h &#8212; Harmony 1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="pthread-h">
<h1>pthread.h<a class="headerlink" href="#pthread-h" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2><strong>Overview</strong><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><strong>Related Modules:</strong></p>
<p><a class="reference external" href="process.md">PROCESS</a></p>
<p><strong>Description:</strong></p>
<p>Provides process- and thread-related structures (providing fields such
as thread attributes) and functions (including the functions for
creating and destroying threads, and setting the thread detach state and
blocking conditions).</p>
<p><strong>Since:</strong></p>
<p>1.0</p>
<p><strong>Version:</strong></p>
<p>1.0</p>
</div>
<div class="section" id="summary">
<h2><strong>Summary</strong><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<table><thead align="left"><tr id="row629732592084831"><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.1"><p id="p1674192319084831"><p>Function Name</p>
</p></th><th class="cellrowborder" valign="top" width="50%" id="mcps1.1.3.1.2"><p id="p1966658112084831"><p>Description</p>
</p></th></tr></thead><tbody><tr id="row1338231546084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1420505920084831"><p>pthread_create (pthread_t <em>thread, const pthread_attr_t</em>attr, void
<em>(</em>start_routine)(void <em>), void</em>arg)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p158737550084831"><p>int</p>
</p><p id="p1499526583084831"><p>Creates a thread.</p>
</p></td></tr><tr id="row141995018084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p274339001084831"><p>pthread_detach (pthread_t thread)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1427776902084831"><p>int</p>
</p><p id="p1748908653084831"><p>Detaches a thread.</p>
</p></td></tr><tr id="row1707637780084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1336791060084831"><p>pthread_exit (void *retval)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1404496180084831"><p>_Noreturn void</p>
</p><p id="p316311595084831"><p>Terminates the calling thread.</p>
</p></td></tr><tr id="row275643329084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1240326946084831"><p>pthread_join (pthread_t thread, void **retval)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1911776136084831"><p>int</p>
</p><p id="p1654684601084831"><p>Waits for a thread to terminate.</p>
</p></td></tr><tr id="row500385784084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p246570847084831"><p>pthread_self (void)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1471574492084831"><p>pthread_t</p>
</p><p id="p1250721980084831"><p>Obtains the ID of the calling thread.</p>
</p></td></tr><tr id="row1322849588084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1399150485084831"><p>pthread_equal (pthread_t t1, pthread_t t2)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1624582945084831"><p>int</p>
</p><p id="p591628834084831"><p>Compares whether two thread IDs are equal.</p>
</p></td></tr><tr id="row1123516869084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p310019677084831"><p>pthread_setcancelstate (int state, int *oldstate)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1375925438084831"><p>int</p>
</p><p id="p13320449084831"><p>Sets the cancelability state for the calling thread.</p>
</p></td></tr><tr id="row327124959084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p530598869084831"><p>pthread_setcanceltype (int type, int *oldtype)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1155242778084831"><p>int</p>
</p><p id="p343036429084831"><p>Sets the cancelability type for the calling thread.</p>
</p></td></tr><tr id="row1525994075084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p969747806084831"><p>pthread_testcancel (void)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p800889596084831"><p>void</p>
</p><p id="p846143272084831"><p>Requests delivery of any pending cancellation request.</p>
</p></td></tr><tr id="row1419595392084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p478578056084831"><p>pthread_cancel (pthread_t thread)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1515902843084831"><p>int</p>
</p><p id="p653290080084831"><p>Sends a cancellation request to a thread.</p>
</p></td></tr><tr id="row1340992926084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p322243165084831"><p>pthread_kill (pthread_t thread, int sig)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1739966800084831"><p>int</p>
</p><p id="p1903311140084831"><p>Sends a signal to a thread.</p>
</p></td></tr><tr id="row1494854668084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p962490977084831"><p>pthread_getschedparam (pthread_t thread, int <em>policy, struct
sched_param</em>param)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1988845719084831"><p>int</p>
</p><p id="p1595724400084831"><p>Obtains the scheduling policy and parameters of a thread.</p>
</p></td></tr><tr id="row1065579712084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p491695424084831"><p>pthread_setschedparam (pthread_t thread, int policy, const struct
sched_param *param)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p258015925084831"><p>int</p>
</p><p id="p1017117311084831"><p>Sets a scheduling policy and parameters for a thread.</p>
</p></td></tr><tr id="row1950245672084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p909485016084831"><p>pthread_setschedprio (pthread_t thread, int prio)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1532326522084831"><p>int</p>
</p><p id="p2136329142084831"><p>Sets a static scheduling priority for a thread.</p>
</p></td></tr><tr id="row2022991064084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p636419163084831"><p>pthread_once (pthread_once_t <em>once_control, void(</em>init_routine)(void))</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p645947359084831"><p>int</p>
</p><p id="p1460939055084831"><p>Enables the initialization function to be called only once.</p>
</p></td></tr><tr id="row1755466003084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p814549636084831"><p>pthread_mutex_init (pthread_mutex_t *__restrict m, const
pthread_mutexattr_t *__restrict a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1141511484084831"><p>int</p>
</p><p id="p1004020697084831"><p>Initializes a mutex.</p>
</p></td></tr><tr id="row1422353289084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1102319312084831"><p>pthread_mutex_lock (pthread_mutex_t *m)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p238347624084831"><p>int</p>
</p><p id="p1153626701084831"><p>Locks a mutex.</p>
</p></td></tr><tr id="row1859001340084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p993807004084831"><p>pthread_mutex_unlock (pthread_mutex_t *m)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p370172725084831"><p>int</p>
</p><p id="p187360236084831"><p>Unlocks a mutex.</p>
</p></td></tr><tr id="row1235779003084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p438775945084831"><p>pthread_mutex_trylock (pthread_mutex_t *m)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2133606930084831"><p>int</p>
</p><p id="p660242088084831"><p>Attempts to lock a mutex.</p>
</p></td></tr><tr id="row894940980084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1879399869084831"><p>pthread_mutex_timedlock (pthread_mutex_t *__restrict m, const struct
timespec *__restrict at)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1030474491084831"><p>int</p>
</p><p id="p1812469817084831"><p>Blocks the calling thread to lock a mutex.</p>
</p></td></tr><tr id="row820503766084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p649748259084831"><p>pthread_mutex_destroy (pthread_mutex_t *m)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p544988886084831"><p>int</p>
</p><p id="p1306499301084831"><p>Destroys a mutex.</p>
</p></td></tr><tr id="row1907510046084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p722057731084831"><p>pthread_cond_init (pthread_cond_t *__restrict c, const
pthread_condattr_t *__restrict a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p415585396084831"><p>int</p>
</p><p id="p327079038084831"><p>Initializes a condition variable.</p>
</p></td></tr><tr id="row821779608084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1329383228084831"><p>pthread_cond_destroy (pthread_cond_t *c)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p569925612084831"><p>int</p>
</p><p id="p411021103084831"><p>Destroys a condition variable.</p>
</p></td></tr><tr id="row382249280084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p522537576084831"><p>pthread_cond_wait (pthread_cond_t *__restrict c, pthread_mutex_t
*__restrict m)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p564636238084831"><p>int</p>
</p><p id="p441388351084831"><p>Blocks the calling thread to wait for the condition set by
pthread_con_signal().</p>
</p></td></tr><tr id="row1755515377084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p314053802084831"><p>pthread_cond_timedwait (pthread_cond_t *__restrict c, pthread_mutex_t
*__restrict m, const struct timespec *__restrict ts)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1291622451084831"><p>int</p>
</p><p id="p1208583012084831"><p>Blocks the calling thread to wait for the condition set by
pthread_con_signal() for a period of time specified by ts.</p>
</p></td></tr><tr id="row1774150005084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p788467754084831"><p>pthread_cond_broadcast (pthread_cond_t *c)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1063472185084831"><p>int</p>
</p><p id="p1860563641084831"><p>Unblocks all threads that are currently blocked on the condition
variable cond.</p>
</p></td></tr><tr id="row108169007084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1194653832084831"><p>pthread_cond_signal (pthread_cond_t *c)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1938786207084831"><p>int</p>
</p><p id="p783221724084831"><p>Unblocks a thread.</p>
</p></td></tr><tr id="row1106926559084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p223804769084831"><p>pthread_rwlock_init (pthread_rwlock_t *__restrict rw, const
pthread_rwlockattr_t *__restrict a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p338836281084831"><p>int</p>
</p><p id="p1909951793084831"><p>Initializes a read-write lock.</p>
</p></td></tr><tr id="row580922433084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p844764665084831"><p>pthread_rwlock_destroy (pthread_rwlock_t *rw)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2029789656084831"><p>int</p>
</p><p id="p1476903852084831"><p>Destroys a read-write lock.</p>
</p></td></tr><tr id="row2041332948084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1589325106084831"><p>pthread_rwlock_rdlock (pthread_rwlock_t *rw)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1379663212084831"><p>int</p>
</p><p id="p83981748084831"><p>Applies a read lock to a read-write lock.</p>
</p></td></tr><tr id="row768609467084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p904300510084831"><p>pthread_rwlock_tryrdlock (pthread_rwlock_t *rw)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1831401027084831"><p>int</p>
</p><p id="p1192924920084831"><p>Attempts to apply a read lock to a read-write lock.</p>
</p></td></tr><tr id="row1195914500084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p123286682084831"><p>pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict rw, const
struct timespec *__restrict at)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p770106311084831"><p>int</p>
</p><p id="p2053532631084831"><p>Blocks the calling thread to lock a read-write lock for reading.</p>
</p></td></tr><tr id="row1753084030084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1813612984084831"><p>pthread_rwlock_wrlock (pthread_rwlock_t *rw)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1492185166084831"><p>int</p>
</p><p id="p1267324456084831"><p>Applies a write lock to a read-write lock.</p>
</p></td></tr><tr id="row918921628084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1230907731084831"><p>pthread_rwlock_trywrlock (pthread_rwlock_t *rw)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p121975858084831"><p>int</p>
</p><p id="p1470047318084831"><p>Attempts to apply a write lock to a read-write lock.</p>
</p></td></tr><tr id="row1830089508084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p402225811084831"><p>pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict rw, const
struct timespec *__restrict at)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2120360381084831"><p>int</p>
</p><p id="p1059318709084831"><p>Blocks the calling thread to lock a read-write lock for writing.</p>
</p></td></tr><tr id="row1333552980084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p334579078084831"><p>pthread_rwlock_unlock (pthread_rwlock_t *rw)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1745255417084831"><p>int</p>
</p><p id="p483843727084831"><p>Unlocks a read-write lock.</p>
</p></td></tr><tr id="row924591775084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1274497422084831"><p>pthread_spin_init (pthread_spinlock_t *s, int shared)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1372482964084831"><p>int</p>
</p><p id="p692957053084831"><p>Initializes a spin lock.</p>
</p></td></tr><tr id="row1274795186084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p720730290084831"><p>pthread_spin_destroy (pthread_spinlock_t *s)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p591624441084831"><p>int</p>
</p><p id="p1853804188084831"><p>Destroys a spin lock.</p>
</p></td></tr><tr id="row643274050084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2060205142084831"><p>pthread_spin_lock (pthread_spinlock_t *s)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p32638432084831"><p>int</p>
</p><p id="p1599634186084831"><p>Locks a spin lock.</p>
</p></td></tr><tr id="row748217708084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p973610773084831"><p>pthread_spin_trylock (pthread_spinlock_t *s)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p521643920084831"><p>int</p>
</p><p id="p416711561084831"><p>Attempts to lock a spin lock.</p>
</p></td></tr><tr id="row342366889084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p626798791084831"><p>pthread_spin_unlock (pthread_spinlock_t *s)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1723386011084831"><p>int</p>
</p><p id="p42497869084831"><p>Unlocks a spin lock.</p>
</p></td></tr><tr id="row1517454319084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1307025977084831"><p>pthread_barrier_init (pthread_barrier_t *__restrict b, const
pthread_barrierattr_t *__restrict a, unsigned count)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p432503584084831"><p>int</p>
</p><p id="p1750743122084831"><p>Initializes a barrier.</p>
</p></td></tr><tr id="row1721000148084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p213461963084831"><p>pthread_barrier_destroy (pthread_barrier_t *b)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p405612242084831"><p>int</p>
</p><p id="p1649906970084831"><p>Destroys a barrier.</p>
</p></td></tr><tr id="row582820070084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p814744780084831"><p>pthread_barrier_wait (pthread_barrier_t *b)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p624337739084831"><p>int</p>
</p><p id="p55238447084831"><p>Synchronizes participating threads at a barrier.</p>
</p></td></tr><tr id="row399081808084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2133870241084831"><p>pthread_key_create (pthread_key_t <em>key, void(</em>destructor)(void *))</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2069186700084831"><p>int</p>
</p><p id="p1250767680084831"><p>Creates a key for thread data.</p>
</p></td></tr><tr id="row524405397084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p261665856084831"><p>pthread_key_delete (pthread_key_t key)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1803698431084831"><p>int</p>
</p><p id="p1781913900084831"><p>Deletes a key for thread data.</p>
</p></td></tr><tr id="row1490494588084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1490043769084831"><p>pthread_getspecific (pthread_key_t key)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p819819440084831"><p>void *</p>
</p><p id="p316080855084831"><p>Obtains specific thread data.</p>
</p></td></tr><tr id="row97121947084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1657109082084831"><p>pthread_setspecific (pthread_key_t key, const void *value)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1738412280084831"><p>int</p>
</p><p id="p1612135869084831"><p>Sets specific thread data.</p>
</p></td></tr><tr id="row1312726078084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2088739510084831"><p>pthread_attr_init (pthread_attr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1405400537084831"><p>int</p>
</p><p id="p600399390084831"><p>Initializes a thread attribute object.</p>
</p></td></tr><tr id="row1715876912084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1406195704084831"><p>pthread_attr_destroy (pthread_attr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p70541783084831"><p>int</p>
</p><p id="p968125547084831"><p>Destroys a thread attribute object.</p>
</p></td></tr><tr id="row1547551324084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p231857140084831"><p>pthread_attr_getguardsize (const pthread_attr_t <em>attr,
size_t</em>guardsize)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p329296708084831"><p>int</p>
</p><p id="p617325603084831"><p>Obtains the guard size of a thread attribute object.</p>
</p></td></tr><tr id="row345992839084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1235092972084831"><p>pthread_attr_setguardsize (pthread_attr_t *attr, size_t guardsize)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1973287078084831"><p>int</p>
</p><p id="p1291680086084831"><p>Sets the guard size for a thread attribute object.</p>
</p></td></tr><tr id="row1887143004084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p592771056084831"><p>pthread_attr_getstacksize (const pthread_attr_t <em>attr,
size_t</em>stacksize)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p756280506084831"><p>int</p>
</p><p id="p1956529050084831"><p>Obtains the stack size of a thread attribute object.</p>
</p></td></tr><tr id="row1108864808084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p44554055084831"><p>pthread_attr_setstacksize (pthread_attr_t *attr, size_t stacksize)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2103548279084831"><p>int</p>
</p><p id="p520366593084831"><p>Sets the stack size for a thread attribute object.</p>
</p></td></tr><tr id="row364800129084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p699710753084831"><p>pthread_attr_getdetachstate (const pthread_attr_t <em>attr,
int</em>detachstate)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p190337036084831"><p>int</p>
</p><p id="p1859032902084831"><p>Obtains the detach state of a thread attribute object.</p>
</p></td></tr><tr id="row555016421084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1629362014084831"><p>pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1167242567084831"><p>int</p>
</p><p id="p661431418084831"><p>Sets the detach state for a thread attribute object.</p>
</p></td></tr><tr id="row149048428084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p881965056084831"><p>pthread_attr_getstack (const pthread_attr_t *attr, void **stackaddr,
size_t *stacksize)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1048339901084831"><p>int</p>
</p><p id="p672582673084831"><p>Obtains stack attributes of a thread attribute object.</p>
</p></td></tr><tr id="row1861962987084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1130614847084831"><p>pthread_attr_setstack (pthread_attr_t <em>attr, void</em>stackaddr, size_t
stacksize)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p441152324084831"><p>int</p>
</p><p id="p602856745084831"><p>Sets stack attributes for a thread attribute object.</p>
</p></td></tr><tr id="row889935092084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1480372976084831"><p>pthread_attr_getscope (const pthread_attr_t <em>arrt, int</em>scope)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1535245185084831"><p>int</p>
</p><p id="p1305851051084831"><p>Obtains contention scope attributes of a thread attribute object.</p>
</p></td></tr><tr id="row1958429859084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p736339643084831"><p>pthread_attr_setscope (pthread_attr_t *arrt, int scope)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1274973072084831"><p>int</p>
</p><p id="p2007504309084831"><p>Sets contention scope attributes for a thread attribute object.</p>
</p></td></tr><tr id="row1913027630084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1269545958084831"><p>pthread_attr_getschedpolicy (const pthread_attr_t <em>attr,
int</em>schedpolicy)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p2061771971084831"><p>int</p>
</p><p id="p1049047212084831"><p>Obtains scheduling policy attributes of a thread attribute object.</p>
</p></td></tr><tr id="row397695594084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p483253293084831"><p>pthread_attr_setschedpolicy (pthread_attr_t *attr, int schedpolicy)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1362811922084831"><p>int</p>
</p><p id="p1501814409084831"><p>Sets scheduling policy attributes for a thread attribute object.</p>
</p></td></tr><tr id="row48985152084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p691822041084831"><p>pthread_attr_getschedparam (const pthread_attr_t <em>attr, struct
sched_param</em>param)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1534724584084831"><p>int</p>
</p><p id="p949790474084831"><p>Obtains scheduling parameter attributes of a thread attribute object.</p>
</p></td></tr><tr id="row1642692139084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p106462006084831"><p>pthread_attr_setschedparam (pthread_attr_t <em>attr, const struct
sched_param</em>param)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p894355443084831"><p>int</p>
</p><p id="p263621543084831"><p>Sets scheduling parameter attributes for a thread attribute object.</p>
</p></td></tr><tr id="row1743889236084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1479594472084831"><p>pthread_attr_getinheritsched (const pthread_attr_t <em>attr,
int</em>inheritsched)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1433533892084831"><p>int</p>
</p><p id="p1814160414084831"><p>Obtains inherit scheduler attributes of a thread attribute object.</p>
</p></td></tr><tr id="row1541463778084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p50885123084831"><p>pthread_attr_setinheritsched (pthread_attr_t *attr, int inheritsched)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p405131685084831"><p>int</p>
</p><p id="p547736646084831"><p>Sets inherit scheduler attributes for a thread attribute object.</p>
</p></td></tr><tr id="row985735702084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p620580933084831"><p>pthread_mutexattr_destroy (pthread_mutexattr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1877499107084831"><p>int</p>
</p><p id="p557249148084831"><p>Destroys a mutex attribute object.</p>
</p></td></tr><tr id="row1834053130084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1602544983084831"><p>pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict attr,
int *__restrict type)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1933104397084831"><p>int</p>
</p><p id="p1656021059084831"><p>Obtains the mutex type attribute.</p>
</p></td></tr><tr id="row1335849793084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p2051563756084831"><p>pthread_mutexattr_init (pthread_mutexattr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1383560030084831"><p>int</p>
</p><p id="p916298987084831"><p>Initializes a mutex attribute object.</p>
</p></td></tr><tr id="row1680577948084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1360726988084831"><p>pthread_mutexattr_settype (pthread_mutexattr_t *attr, int type)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1787708123084831"><p>int</p>
</p><p id="p1889169699084831"><p>Sets the mutex type attribute.</p>
</p></td></tr><tr id="row1937461344084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1766030892084831"><p>pthread_condattr_init (pthread_condattr_t *a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p393537776084831"><p>int</p>
</p><p id="p124172070084831"><p>Initializes a condition variable attribute object.</p>
</p></td></tr><tr id="row842013558084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1102933516084831"><p>pthread_condattr_destroy (pthread_condattr_t *a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1948093895084831"><p>int</p>
</p><p id="p645025015084831"><p>Destroys a condition variable attribute object.</p>
</p></td></tr><tr id="row1194238766084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p61272094084831"><p>pthread_condattr_setclock (pthread_condattr_t *a, clockid_t clk)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p498304829084831"><p>int</p>
</p><p id="p675838331084831"><p>Sets a clock for a condition variable attribute object.</p>
</p></td></tr><tr id="row1204595935084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p451371700084831"><p>pthread_condattr_getclock (const pthread_condattr_t *__restrict a,
clockid_t *__restrict clk)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p978804122084831"><p>int</p>
</p><p id="p117694865084831"><p>Obtains the clock of a condition variable attribute object.</p>
</p></td></tr><tr id="row865642635084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p94339740084831"><p>pthread_rwlockattr_init (pthread_rwlockattr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1884251426084831"><p>int</p>
</p><p id="p1300943600084831"><p>Initializes a read-write lock attribute object.</p>
</p></td></tr><tr id="row1025309419084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1488661024084831"><p>pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p889346200084831"><p>int</p>
</p><p id="p1292284431084831"><p>Destroys a read-write lock attribute object.</p>
</p></td></tr><tr id="row1000717963084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p456292394084831"><p>pthread_barrierattr_destroy (pthread_barrierattr_t *a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p919171016084831"><p>int</p>
</p><p id="p1681371465084831"><p>Destroys a barrier attribute object.</p>
</p></td></tr><tr id="row1007660618084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1372238609084831"><p>pthread_barrierattr_init (pthread_barrierattr_t *a)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p643437975084831"><p>int</p>
</p><p id="p2079628309084831"><p>Initializes a barrier attribute object.</p>
</p></td></tr><tr id="row1737437712084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p512421754084831"><p>pthread_atfork (void(<em>prepare)(void), void(</em>parent)(void),
void(<a href="#id1"><span class="problematic" id="id2">*</span></a>child)(void))</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p612378556084831"><p>int</p>
</p><p id="p1117042248084831"><p>Registers a fork handler to be called before and after fork().</p>
</p></td></tr><tr id="row1035158548084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1805223837084831"><p>pthread_cleanup_push (void(<em>routine)(void</em>), void *arg)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p637442076084831"><p>void</p>
</p><p id="p881017134084831"><p>Pushes the routine to the top of the clean-up handler stack.</p>
</p></td></tr><tr id="row61896709084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p270282937084831"><p>pthread_cleanup_pop (int execute)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p1174941274084831"><p>void</p>
</p><p id="p907610598084831"><p>Removes the routine at the top of the clean-up handler stack.</p>
</p></td></tr><tr id="row81027234084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p180392888084831"><p>pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p759119449084831"><p>int</p>
</p><p id="p2024641697084831"><p>Obtains the attributes of a created thread.</p>
</p></td></tr><tr id="row213558680084831"><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.1 "><p id="p1245593825084831"><p>pthread_setname_np (pthread_t pthread, const char *name)</p>
</p></td><td class="cellrowborder" valign="top" width="50%" headers="mcps1.1.3.1.2 "><p id="p790630260084831"><p>int</p>
</p><p id="p1964451861084831"><p>Sets the thread name.</p>
</p></td></tr></tbody></table></div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Harmony</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Arul.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/docs-en/api/api-SmartVision-Devices/pthread-h.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>