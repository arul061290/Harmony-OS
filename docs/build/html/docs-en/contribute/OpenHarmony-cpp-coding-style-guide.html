
<!DOCTYPE html>

<html lang="y">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C++ Coding Style Guide &#8212; Harmony 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="c-coding-style-guide">
<h1>C++ Coding Style Guide<a class="headerlink" href="#c-coding-style-guide" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Purpose</p>
</div></blockquote>
<hr class="docutils" />
<p>Rules are not perfect. Disabling useful features in specific situations
may affect code implementation. However, the rules are formulated “to
help most programmers to get more benefits”. If a rule is found
unhelpful or difficult to follow in team coding, please send your
feedback to us so we can improve the rule accordingly. Before referring
to this guide, you are expected to have the following basic capabilities
for C++. It is not for a beginner that wants to learn about C++. 1. Have
a general knowledge of ISO standards for C++. 2. Be familiar with the
basic features of C++, including those of C++ 03/11/14/17. 3. Have a
general knowledge of the C++ Standard Library.</p>
<div class="section" id="general-principles">
<h2>General Principles<a class="headerlink" href="#general-principles" title="Permalink to this headline">¶</a></h2>
<p>Code must meet the requirements for readability, maintainability,
security, reliability, testability, efficiency, and portability while
ensuring functionality correctness.</p>
<blockquote>
<div><p>Key Points</p>
</div></blockquote>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>C++ programming style, such as naming and typesetting.</p></li>
<li><p>C++ modular design, including how to design header files, classes,
interfaces, and functions.</p></li>
<li><p>Best practices of C++ features, including constants, type casting,
resource management, and templates.</p></li>
<li><p>Best practices of modern C++, including conventions that can improve
code maintainability and reliability in C++ 11/14/17.</p></li>
</ol>
<blockquote>
<div><p>Conventions</p>
</div></blockquote>
<hr class="docutils" />
<p><strong>Rule</strong>: a regulating principle that must be followed during
programming.</p>
<p><strong>Recommendation</strong>: a guideline that must be considered during
programming.</p>
<p>This document is applicable to standard C++ versions (C++ 03/11/14/17)
unless otherwise specified in the rule.</p>
<blockquote>
<div><p>Exceptions</p>
</div></blockquote>
<hr class="docutils" />
<p>It is necessary to understand the reason for each rule or recommendation
and to try and comply with them. However, some rules and recommendations
have exceptions.</p>
<p>The only acceptable exceptions are those that do not violate the general
principles and provide appropriate reasons for the exception. Try to
avoid exceptions because they affect the code consistency. Exceptions to
‘Rules’ should be very rare.</p>
<div class="line-block">
<div class="line">The style consistency principle is preferred in the following case:</div>
<div class="line">When you modify external open source or third-party code, the existing
code specifications prevail.</div>
</div>
</div>
</div>
<div class="section" id="naming">
<h1>2 Naming<a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general-naming-rules">
<h2>General Naming Rules<a class="headerlink" href="#general-naming-rules" title="Permalink to this headline">¶</a></h2>
<p><strong>CamelCase</strong> CamelCase is the practice of writing compound words or
phrases so that each word or abbreviation in the phrase begins with a
capital letter, with no intervening spaces or punctuation. There are two
conventions: UpperCamelCase and lowerCamelCase.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Naming Style</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Class Type, Struct Type,
Enumeration Type, and Union Type
Definitions, Scope Name</p></td>
<td><p>UpperCamelCase</p></td>
</tr>
<tr class="row-odd"><td><p>Functions (Including Global
Functions, Scope Functions, and
Member Functions)</p></td>
<td><p>UpperCamelCase</p></td>
</tr>
<tr class="row-even"><td><p>Global Variables (Including
Variables of the Global and
Namespace Scopes, Namespace
Variables, and Class Static
Variables), Local Variables,
Function Parameters, and Class,
Struct, and Union Member
Variables</p></td>
<td><p>lowerCamelCase</p></td>
</tr>
<tr class="row-odd"><td><p>Macro, Constant, Enumerated
Value, goto Tag</p></td>
<td><p>All caps, separated with
underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>)</p></td>
</tr>
</tbody>
</table>
<p>Note: <strong>Constant</strong> indicates the variables of the basic, enumeration, or
character string type modified by const or constexpr in the global
scope, the namespace scope, and the scope of a static member of a class.
<strong>Variable</strong> indicates the variables excluding those defined in
<strong>Constant</strong>. These variables use the lowerCamelCase style.</p>
<blockquote>
<div><p>File Names</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>Recommendation 2.2.1 Use .cpp as the C++ file name extension and .h as the header file name extension.</p>
</div></blockquote>
<hr class="docutils" />
<p>It is recommended that you use .h as the name extension of a header file
so that the header file can be directly compatible with C and C++. It is
recommended that you use .cpp as the name extension of an implementation
file. In this way, you can directly distinguish C++ code from C code.</p>
<p>At present, there are some other file name extensions used by
programmers:</p>
<ul class="simple">
<li><p>Header files: .hh, .hpp, .hxx</p></li>
<li><p>Implementation files: .cc, .cxx, .C</p></li>
</ul>
<p>If your project team uses a specific file name extension, you can
continue to use it and keep the style consistent. This document uses .h
and .cpp extensions.</p>
<div class="section" id="recommendation-2-2-2-keep-c-file-names-the-same-as-the-class-name">
<h3>Recommendation 2.2.2 Keep C++ file names the same as the class name.<a class="headerlink" href="#recommendation-2-2-2-keep-c-file-names-the-same-as-the-class-name" title="Permalink to this headline">¶</a></h3>
<p>The names of the C++ header file and the C++ implementation file must be
the same as the class name. Use the CamelCase or Kernel style and keep
the style consistent.</p>
<p>For example, if there is a class named DatabaseConnection, the
corresponding file names are as follows: - database_connection.h -
database_connection.cpp</p>
<p>The naming rules of struct, namespace, and enumeration definition files
are similar to the rules above.</p>
<blockquote>
<div><p>Function Names</p>
</div></blockquote>
<hr class="docutils" />
<p>Functions are named in UpperCamelCase. Generally, the verb or
verb-object structure is used.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">AddElement</span><span class="p">(</span><span class="k">const</span> <span class="n">Element</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">);</span>
      <span class="n">Element</span> <span class="nf">GetElement</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">namespace</span> <span class="n">Utils</span> <span class="p">{</span>
      <span class="kt">void</span> <span class="nf">DeleteUser</span><span class="p">();</span>
  <span class="p">}</span>

<span class="n">Type</span> <span class="n">Names</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Types are named in the UpperCamelCase style. All types, such as classes,
structs, unions, typedefs, and enumerations, use the same conventions.
For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// classes, structs and unions</span>
<span class="k">class</span> <span class="nc">UrlTable</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">class</span> <span class="nc">UrlTableTester</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">struct</span> <span class="nc">UrlTableProperties</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">union</span> <span class="nc">Packet</span> <span class="p">{</span> <span class="p">...</span>

<span class="c1">// typedefs</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">UrlTableProperties</span><span class="o">*&gt;</span> <span class="n">PropertiesMap</span><span class="p">;</span>

<span class="c1">// enums</span>
<span class="k">enum</span> <span class="nc">UrlTableErrors</span> <span class="p">{</span> <span class="p">...</span>
</pre></div>
</div>
<p>For namespace naming, UpperCamelCase is recommended.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// namespace</span>
<span class="k">namespace</span> <span class="n">OsUtils</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="n">FileUtils</span> <span class="p">{</span>

<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-2-4-1-do-not-abuse-typedef-or-define-to-alias-basic-types">
<h3>Recommendation 2.4.1 Do not abuse typedef or #define to alias basic types.<a class="headerlink" href="#recommendation-2-4-1-do-not-abuse-typedef-or-define-to-alias-basic-types" title="Permalink to this headline">¶</a></h3>
<p>Unless otherwise specified, do not use typedef or #define to redefine a
basic value type. The basic types found in the <code class="docutils literal notranslate"><span class="pre">&lt;cstdint&gt;</span></code> header file
are preferable.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 19%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Signed
Type</p></th>
<th class="head"><p>Unsigned
Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int8_t</p></td>
<td><p>uint8_t</p></td>
<td><p>The signed or unsigned 8-bit integer type.</p></td>
</tr>
<tr class="row-odd"><td><p>int16_t</p></td>
<td><p>uint16_t</p></td>
<td><p>The signed or unsigned 16-bit integer
type.</p></td>
</tr>
<tr class="row-even"><td><p>int32_t</p></td>
<td><p>uint32_t</p></td>
<td><p>The signed or unsigned 32-bit integer
type.</p></td>
</tr>
<tr class="row-odd"><td><p>int64_t</p></td>
<td><p>uint64_t</p></td>
<td><p>The signed or unsigned 64-bit integer
type.</p></td>
</tr>
<tr class="row-even"><td><p>intptr_t</p></td>
<td><p>uintptr_t</p></td>
<td><p>The signed or unsigned integer type large
enough to hold a pointer.</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Variable Names</p>
</div></blockquote>
<hr class="docutils" />
<p>General variables are named in lowerCamelCase, including global
variables, function parameters, local variables, and member variables.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>  <span class="c1">// Good: Recommended style.</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tablename</span><span class="p">;</span>  <span class="c1">// Bad: Forbidden style.</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">;</span>       <span class="c1">// Good: When there is only one word, lowerCamelCase (all lowercase) is used.</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-2-5-1-add-the-prefix-g-to-global-variables-do-not-add-a-prefix-to-a-static-variable">
<h3>Rule 2.5.1 Add the prefix ‘g_’ to global variables. Do not add a prefix to a static variable.<a class="headerlink" href="#rule-2-5-1-add-the-prefix-g-to-global-variables-do-not-add-a-prefix-to-a-static-variable" title="Permalink to this headline">¶</a></h3>
<p>Global variables should be used as little as possible, and special
attention should be paid to the use of global variables. This prefix
highlights global variables so that developers can be more careful when
handling them. - Global static variables and global variables are named
in the same way. - Static variables and common local variables in
functions are named in the same way. - Static member variables and
common member variables of classes are named in the same way.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">g_activeConnectCount</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">packetCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-2-5-2-name-member-variables-in-classes-based-on-the-three-styles-of-the-lowercamelcase-and-maintain-a-uniform-coding-style-for-a-product-or-project">
<h3>Rule 2.5.2 Name member variables in classes based on the three styles of the lowerCamelCase and maintain a uniform coding style for a product or project.<a class="headerlink" href="#rule-2-5-2-name-member-variables-in-classes-based-on-the-three-styles-of-the-lowercamelcase-and-maintain-a-uniform-coding-style-for-a-product-or-project" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fileName_</span><span class="p">;</span>   <span class="c1">// Add the _ postfix, similar to the K&amp;R naming style.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Use the lowerCamelCase style and do not add prefixes or suffixes to name
a member variable of the struct or union type. Keep the naming style
consistent with that for a local variable.</p>
<blockquote>
<div><p>Macro, Constant, and Enumeration Names</p>
</div></blockquote>
<hr class="docutils" />
<p>For macros and enumerated values, use all caps separated with
underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>). In the global scope, constants of named and unnamed
namespaces and static member constants should be capitalized and
separated with underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>). Local constants and ordinary const
member variables use the lowerCamelCase naming style.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MAX(a, b) (((a) &lt; (b))? (b): (a)) </span><span class="c1">// Though examples of Macro names are made, you are not advised to use macros to implement this function.</span>

<span class="k">enum</span> <span class="nc">BaseColor</span> <span class="p">{</span>    <span class="c1">// Note: Enumerated types are named in the UpperCamelCase style, while their values are all capitalized and separated with underscores (_).</span>
    <span class="n">RED</span><span class="p">,</span>
    <span class="n">DARK_RED</span><span class="p">,</span>
    <span class="n">GREEN</span><span class="p">,</span>
    <span class="n">LIGHT_GREEN</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">Func</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufferSize</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>    <span class="c1">// Local variable</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">bufferSize</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Utils</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">DEFAULT_FILE_SIZE_KB</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>        <span class="c1">// Global variable</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="formatting">
<h1>3 Formatting<a class="headerlink" href="#formatting" title="Permalink to this headline">¶</a></h1>
<div class="section" id="line-length">
<h2>Line Length<a class="headerlink" href="#line-length" title="Permalink to this headline">¶</a></h2>
<div class="section" id="recommendation-3-1-1-each-line-of-code-should-contain-a-maximum-of-120-characters">
<h3>Recommendation 3.1.1 Each line of code should contain a maximum of 120 characters.<a class="headerlink" href="#recommendation-3-1-1-each-line-of-code-should-contain-a-maximum-of-120-characters" title="Permalink to this headline">¶</a></h3>
<p>** Note: **It is recommended that the number of characters in each
line not exceed 120. It is recommended that the number of characters in
each line not exceed 120. If the line of code exceeds the permitted
length, wrap the line appropriately.</p>
<p>Exception: - If a one-line comment contains a command or URL of more
than 120 characters, you can keep the line for ease in using copy,
paste, and search using the grep command. - The length of an
<code class="docutils literal notranslate"><span class="pre">#include</span></code> statement can contain a long path exceeding 120 characters,
but this should be avoided if possible. - The error information in
preprocessor directives can exceed the permitted length. Put the error
information of preprocessor directives in one line to facilitate reading
and understanding even if the line contains more than 120 characters.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef XXX_YYY_ZZZ</span>
<span class="cp">#error Header aaaa/bbbb/cccc/abc.h must only be included after xxxx/yyyy/zzzz/xyz.h, because xxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="indentation">
<h2>Indentation<a class="headerlink" href="#indentation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rule-3-2-1-use-spaces-to-indent-and-indent-4-spaces-at-a-time">
<h3>Rule 3.2.1 Use spaces to indent and indent 4 spaces at a time.<a class="headerlink" href="#rule-3-2-1-use-spaces-to-indent-and-indent-4-spaces-at-a-time" title="Permalink to this headline">¶</a></h3>
<p>Only spaces can be used for indentation. Four spaces are indented each
time. Do not use the Tab character to indent. Currently, almost all IDEs
support automatic expansion of a Tab to 4 spaces upon pressing the tab
key. Please configure your IDE to do so.</p>
</div>
</div>
<div class="section" id="braces">
<h2>Braces<a class="headerlink" href="#braces" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rule-3-3-1-use-the-k-r-indentation-writing-style">
<h3>Rule 3.3.1 Use the K&amp;R indentation writing style.<a class="headerlink" href="#rule-3-3-1-use-the-k-r-indentation-writing-style" title="Permalink to this headline">¶</a></h3>
<p><strong>K&amp;R style</strong> When a line break is required, the left brace of a
function (excluding the lambda statement) starts a new line. One space
should be placed between the statement and the brace. The right brace
starts a new line and nothing else is placed on the line, unless it is
followed by the remaining part of the same statement, for example,
“while” in the do statement, “else” or “else if” in the if statement, a
comma, and a semicolon.</p>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">MyType</span> <span class="p">{</span>     <span class="c1">// Follow the statement to the end, and indent one space.</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>                   <span class="c1">// The left brace of the function starts a new line, nothing else is placed on the line.</span>
    <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The reasons for recommending this style are as follows:</p>
<ul class="simple">
<li><p>Code is more compact.</p></li>
<li><p>Placing the brace at the end of the statement makes the code more
continuous in reading rhythm than starting a new line.</p></li>
<li><p>This style complies with mainstream norms and habits of programming
languages.</p></li>
<li><p>Most modern IDEs have an automatic code indentation, alignment and
display. Placing the brace at the end of a line does not impact
understanding.</p></li>
</ul>
<p>If no function body is inside the braces, the braces can be put on the
same line.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">MyClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
  <span class="p">};</span>

<span class="n">Function</span> <span class="n">Declarations</span> <span class="n">and</span> <span class="n">Definitions</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-4-1-the-return-type-and-the-function-name-of-a-function-declaration-or-definition-must-be-on-the-same-line-when-the-length-of-the-function-parameter-list-exceeds-the-permitted-length-a-line-break-is-required-and-parameters-must-be-aligned-appropriately">
<h3>Rule 3.4.1 The return type and the function name of a function declaration or definition must be on the same line. When the length of the function parameter list exceeds the permitted length, a line break is required and parameters must be aligned appropriately.<a class="headerlink" href="#rule-3-4-1-the-return-type-and-the-function-name-of-a-function-declaration-or-definition-must-be-on-the-same-line-when-the-length-of-the-function-parameter-list-exceeds-the-permitted-length-a-line-break-is-required-and-parameters-must-be-aligned-appropriately" title="Permalink to this headline">¶</a></h3>
<p>When a function is declared or defined, the return value type of the
function should be on the same line as the function name. If the line
length permits, the function parameters should be placed on the same
line. Otherwise, the function parameters should be wrapped and properly
aligned. The left parenthesis of a parameter list should always be on
the same line as the function name. The right parenthesis always follows
the last parameter.</p>
<p>The following is an example of line breaks:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="nf">FunctionName</span><span class="p">(</span><span class="n">ArgType</span> <span class="n">paramName1</span><span class="p">,</span> <span class="n">ArgType</span> <span class="n">paramName2</span><span class="p">)</span>   <span class="c1">// Good: All are in the same line.</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">ReturnType</span> <span class="nf">VeryVeryVeryLongFunctionName</span><span class="p">(</span><span class="n">ArgType</span> <span class="n">paramName1</span><span class="p">,</span>     <span class="c1">// Each added parameter starts on a new line because the line length limit is exceeded.</span>
                                        <span class="n">ArgType</span> <span class="n">paramName2</span><span class="p">,</span>     <span class="c1">// Good: aligned with the previous parameter.</span>
                                        <span class="n">ArgType</span> <span class="n">paramName3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">ReturnType</span> <span class="nf">LongFunctionName</span><span class="p">(</span><span class="n">ArgType</span> <span class="n">paramName1</span><span class="p">,</span> <span class="n">ArgType</span> <span class="n">paramName2</span><span class="p">,</span> <span class="c1">// Parameters are wrapped because the line length limit is exceeded.</span>
    <span class="n">ArgType</span> <span class="n">paramName3</span><span class="p">,</span> <span class="n">ArgType</span> <span class="n">paramName4</span><span class="p">,</span> <span class="n">ArgType</span> <span class="n">paramName5</span><span class="p">)</span>     <span class="c1">// Good: After the line break, 4 spaces are used for indentation.</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">ReturnType</span> <span class="nf">ReallyReallyReallyReallyLongFunctionName</span><span class="p">(</span>            <span class="c1">// The line length cannot accommodate even the first parameter, and a line break is required.</span>
    <span class="n">ArgType</span> <span class="n">paramName1</span><span class="p">,</span> <span class="n">ArgType</span> <span class="n">paramName2</span><span class="p">,</span> <span class="n">ArgType</span> <span class="n">paramName3</span><span class="p">)</span> <span class="c1">// Good: After the line break, 4 spaces are used for indentation.</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="function-calls">
<h2>Function Calls<a class="headerlink" href="#function-calls" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rule-3-5-1-a-function-call-parameter-list-should-be-placed-on-one-line-when-the-parameter-list-exceeds-the-line-length-and-requires-a-line-break-the-parameters-should-be-properly-aligned">
<h3>Rule 3.5.1 A function call parameter list should be placed on one line. When the parameter list exceeds the line length and requires a line break, the parameters should be properly aligned.<a class="headerlink" href="#rule-3-5-1-a-function-call-parameter-list-should-be-placed-on-one-line-when-the-parameter-list-exceeds-the-line-length-and-requires-a-line-break-the-parameters-should-be-properly-aligned" title="Permalink to this headline">¶</a></h3>
<p>A function call parameter list should be placed on one line. When the
parameter list exceeds the line length and requires a line break, the
parameters should be properly aligned. The left parenthesis always
follows the function name, and the right parenthesis always follows the
last parameter.</p>
<p>The following are examples of proper line breaks:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">result</span> <span class="o">=</span> <span class="n">FunctionName</span><span class="p">(</span><span class="n">paramName1</span><span class="p">,</span> <span class="n">paramName2</span><span class="p">);</span>   <span class="c1">// Good: All function parameters are on one line.</span>

<span class="n">ReturnType</span> <span class="n">result</span> <span class="o">=</span> <span class="n">FunctionName</span><span class="p">(</span><span class="n">paramName1</span><span class="p">,</span>
                                 <span class="n">paramName2</span><span class="p">,</span>                <span class="c1">// Good: aligned with the previous parameter</span>
                                 <span class="n">paramName3</span><span class="p">);</span>

<span class="n">ReturnType</span> <span class="n">result</span> <span class="o">=</span> <span class="n">FunctionName</span><span class="p">(</span><span class="n">paramName1</span><span class="p">,</span> <span class="n">paramName2</span><span class="p">,</span>
    <span class="n">paramName3</span><span class="p">,</span> <span class="n">paramName4</span><span class="p">,</span> <span class="n">paramName5</span><span class="p">);</span>                    <span class="c1">// Good: Parameters are wrapped. After the line break, 4 spaces are used for indentation.</span>

<span class="n">ReturnType</span> <span class="n">result</span> <span class="o">=</span> <span class="n">VeryVeryVeryLongFunctionName</span><span class="p">(</span>           <span class="c1">// The line length cannot accommodate even the first parameter, and a line break is required.</span>
    <span class="n">paramName1</span><span class="p">,</span> <span class="n">paramName2</span><span class="p">,</span> <span class="n">paramName3</span><span class="p">);</span>                    <span class="c1">// After the line break, 4 spaces are used for indentation.</span>
</pre></div>
</div>
<p>If some of the parameters called by a function are associated with each
other, you can group them for better understanding.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Good: The parameters in each line represent a group of data structures with strong correlation. They are placed on a line for ease of understanding.</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">DealWithStructureLikeParams</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">left</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>     <span class="c1">// A group of related parameters.</span>
                                           <span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  <span class="c1">// Another group of related parameters.</span>

<span class="k">if</span> <span class="n">Statements</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-6-1-use-braces-to-include-an-if-statement">
<h3>Rule 3.6.1 Use braces to include an if statement.<a class="headerlink" href="#rule-3-6-1-use-braces-to-include-an-if-statement" title="Permalink to this headline">¶</a></h3>
<p>We require that all if statements use braces, even if there is only one
statement.</p>
<p>Reasons: - The logic is intuitive and easy to read. - It is less prone
to mistakes when new code is added to the existing if statement. - If
function-like macros are used in a conditional statement, it is less
prone to mistakes (in case the braces are missing when macros are
defined).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">objectIsNotExist</span><span class="p">)</span> <span class="p">{</span>         <span class="c1">// Good: Braces are added to a single-line conditional statement.</span>
    <span class="k">return</span> <span class="nf">CreateNewObject</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-3-6-2-place-if-else-and-else-if-keywords-on-separate-lines">
<h3>Rule 3.6.2 Place if, else, and else if keywords on separate lines.<a class="headerlink" href="#rule-3-6-2-place-if-else-and-else-if-keywords-on-separate-lines" title="Permalink to this headline">¶</a></h3>
<p>If there are multiple branches in a conditional statement, they should
be placed on separate lines.</p>
<p>Good example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">someConditions</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Good: Put the if and else keywords on separate lines.</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bad example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">someConditions</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// Bad: The if and else keywords are put on the same line.</span>

<span class="n">Loop</span> <span class="n">Statements</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-7-1-use-braces-after-loop-statements">
<h3>Rule 3.7.1 Use braces after loop statements.<a class="headerlink" href="#rule-3-7-1-use-braces-after-loop-statements" title="Permalink to this headline">¶</a></h3>
<p>Similar to if statements, we require that the for and while loop
statements contain braces, even if the loop body is empty or there is
only one loop statement.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">someRange</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// Good: Braces are used.</span>
    <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Good: The while loop body is empty. Braces should be used.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span> <span class="c1">// Good: The continue keyword highlights the end of the empty loop. Braces should be used.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bad example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">someRange</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">DoSomething</span><span class="p">();</span>      <span class="c1">// Bad: Braces are mandatory.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">while</span> <span class="p">(</span><span class="n">someCondition</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// Bad: Using a semicolon here will make people misunderstand that it is a part of the while statement and not the end to it.</span>

<span class="n">Switch</span> <span class="n">Statements</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-8-1-indent-case-and-default-in-a-switch-statement-with-four-spaces">
<h3>Rule 3.8.1 Indent case and default in a switch statement with four spaces.<a class="headerlink" href="#rule-3-8-1-indent-case-and-default-in-a-switch-statement-with-four-spaces" title="Permalink to this headline">¶</a></h3>
<p>The indentation style of the switch statement is as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>             <span class="c1">// Good: Indented</span>
        <span class="n">DoSomething1</span><span class="p">();</span> <span class="c1">// Good: Indented</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>           <span class="c1">// Good: Braces are added.</span>
        <span class="n">DoSomething2</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>                 <span class="c1">// Bad: case is not indented.</span>
      <span class="n">DoSomething</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span>                <span class="c1">// Bad: default is not indented.</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

<span class="n">Expressions</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-3-9-1-keep-a-consistent-line-break-style-for-expressions-and-ensure-that-operators-are-placed-at-the-end-of-a-line">
<h3>Recommendation 3.9.1 Keep a consistent line break style for expressions and ensure that operators are placed at the end of a line.<a class="headerlink" href="#recommendation-3-9-1-keep-a-consistent-line-break-style-for-expressions-and-ensure-that-operators-are-placed-at-the-end-of-a-line" title="Permalink to this headline">¶</a></h3>
<p>A long expression that does not meet the line length requirement must be
wrapped appropriately. Generally, the expression is wrapped at an
operator of a lower priority or a connector, and the operator or
connector is placed at the end of the line. Placing these at the end of
a line indicates that the operation is to be continued on the next line.
For example:</p>
<p>// Assume that the first line exceeds the length limit.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">currentValue</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">&amp;&amp;</span>  <span class="c1">// Good: After the line break, the logical-AND operators are placed at the end of the line.</span>
    <span class="n">someConditionsion</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">reallyReallyLongVariableName1</span> <span class="o">+</span>    <span class="c1">// Good</span>
             <span class="n">reallyReallyLongVariableName2</span><span class="p">;</span>
</pre></div>
</div>
<p>After an expression is wrapped, ensure that the lines are aligned
appropriately or indented with 4 spaces. See the following example.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">longVaribleName1</span> <span class="o">+</span> <span class="n">longVaribleName2</span> <span class="o">+</span> <span class="n">longVaribleName3</span> <span class="o">+</span>
      <span class="n">longVaribleName4</span> <span class="o">+</span> <span class="n">longVaribleName5</span> <span class="o">+</span> <span class="n">longVaribleName6</span><span class="p">;</span>         <span class="c1">// Good: indented with 4 spaces</span>

  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">longVaribleName1</span> <span class="o">+</span> <span class="n">longVaribleName2</span> <span class="o">+</span> <span class="n">longVaribleName3</span> <span class="o">+</span>
            <span class="n">longVaribleName4</span> <span class="o">+</span> <span class="n">longVaribleName5</span> <span class="o">+</span> <span class="n">longVaribleName6</span><span class="p">;</span>   <span class="c1">// Good: The lines are aligned.</span>

<span class="n">Variable</span> <span class="n">Assignment</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-10-1-multiple-variable-definitions-and-assignment-statements-cannot-be-written-on-one-line">
<h3>Rule 3.10.1 Multiple variable definitions and assignment statements cannot be written on one line.<a class="headerlink" href="#rule-3-10-1-multiple-variable-definitions-and-assignment-statements-cannot-be-written-on-one-line" title="Permalink to this headline">¶</a></h3>
<p>Each line should have only one variable initialization statement. It is
easier to read and understand.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">isCompleted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>
</div>
<p>Bad example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="kt">bool</span> <span class="n">isCompleted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Bad: Multiple variable initialization statements must be separated on different lines. Each variable initialization statement occupies one line.</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Bad: Multiple variable definitions must be separated on different lines. Each definition occupies one line.</span>

<span class="kt">int</span> <span class="n">pointX</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">pointY</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">pointX</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">pointY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// Bad: Multiple variable assignment statements must be separated on different lines.</span>
</pre></div>
</div>
<p>Exception: Multiple variables can be declared and initialized in the for
loop header, if initialization statement (C++17), and structured binding
statement (C++17). Multiple variable declarations in these statements
have strong associations. Forcible division into multiple lines may
cause problems such as scope inconsistency and separation of declaration
from initialization.</p>
<blockquote>
<div><p>Initialization</p>
</div></blockquote>
<hr class="docutils" />
<p>Initialization is applicable to structs, unions, and arrays.</p>
</div>
<div class="section" id="rule-3-11-1-when-an-initialization-list-is-wrapped-ensure-that-the-line-after-the-break-is-indented-and-aligned-properly">
<h3>Rule 3.11.1 When an initialization list is wrapped, ensure that the line after the break is indented and aligned properly.<a class="headerlink" href="#rule-3-11-1-when-an-initialization-list-is-wrapped-ensure-that-the-line-after-the-break-is-indented-and-aligned-properly" title="Permalink to this headline">¶</a></h3>
<p>If a structure or array initialization list is wrapped, the line after
the break is indented with four spaces. Choose the wrap location and
alignment style for best comprehension.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">const</span> <span class="kt">int</span> <span class="n">rank</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span>
      <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>
  <span class="p">};</span>

<span class="n">Pointers</span> <span class="n">and</span> <span class="n">References</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-3-12-1-the-pointer-type-follows-a-variable-name-or-type-there-can-be-only-one-space-to-the-side-of-it">
<h3>Recommendation 3.12.1 The pointer type <code class="docutils literal notranslate"><span class="pre">*</span></code> follows a variable name or type. There can be only one space to the side of it.<a class="headerlink" href="#recommendation-3-12-1-the-pointer-type-follows-a-variable-name-or-type-there-can-be-only-one-space-to-the-side-of-it" title="Permalink to this headline">¶</a></h3>
<p>Pointer naming: There can be only one space next to <code class="docutils literal notranslate"><span class="pre">*</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// Good</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// Good</span>

<span class="kt">int</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// Bad</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// Bad</span>
</pre></div>
</div>
<p>Exception: When a variable is modified by const or restrict, <code class="docutils literal notranslate"><span class="pre">*</span></code>
cannot follow the variable or type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">VERSION</span> <span class="o">=</span> <span class="s">&quot;V100&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-3-12-2-the-reference-type-follows-a-variable-name-or-type-there-can-be-only-one-space-to-the-side-of-it">
<h3>Recommendation 3.12.2 The reference type <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> follows a variable name or type. There can be only one space to the side of it.<a class="headerlink" href="#recommendation-3-12-2-the-reference-type-follows-a-variable-name-or-type-there-can-be-only-one-space-to-the-side-of-it" title="Permalink to this headline">¶</a></h3>
<p>Reference naming: There can be only one space around <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>     <span class="c1">// Good</span>
  <span class="kt">int</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>     <span class="c1">// Good</span>
  <span class="kt">int</span><span class="o">*&amp;</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">// Good: The reference type `*&amp;` follows the type.</span>
  <span class="kt">int</span> <span class="o">*&amp;</span><span class="n">rp</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">// Good: The reference type `*&amp;` follows the variable name.</span>
  <span class="kt">int</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">rp</span> <span class="o">=</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">// Good: The pointer type `*` follows the type and the eference type `&amp;` follows the variable name.</span>

  <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// Bad</span>
  <span class="kt">int</span><span class="o">&amp;</span><span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>      <span class="c1">// Bad</span>

<span class="n">Preprocessor</span> <span class="n">Directives</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-13-1-the-number-sign-that-starts-a-preprocessor-directive-must-be-at-the-beginning-of-the-line-and-can-be-indented-in-nested-preprocessor-directives">
<h3>Rule 3.13.1 The number sign (#) that starts a preprocessor directive must be at the beginning of the line and can be indented in nested preprocessor directives.<a class="headerlink" href="#rule-3-13-1-the-number-sign-that-starts-a-preprocessor-directive-must-be-at-the-beginning-of-the-line-and-can-be-indented-in-nested-preprocessor-directives" title="Permalink to this headline">¶</a></h3>
<p>The number sign (#) that starts a preprocessor directive must be at the
beginning of the line even through the preprocessor directive is inside
a function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(__x86_64__) &amp;&amp; defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16) </span><span class="c1">// Good: &quot;#&quot; is at the beginning of the line.</span>
<span class="cp">#define ATOMIC_X86_HAS_CMPXCHG16B 1  </span><span class="c1">// Good: &quot;#&quot; is at the beginning of the line.</span>
<span class="cp">#else</span>
<span class="cp">#define ATOMIC_X86_HAS_CMPXCHG16B 0</span>
<span class="cp">#endif</span>


<span class="kt">int</span> <span class="nf">FunctionName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">someThingError</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
<span class="cp">#ifdef HAS_SYSLOG        </span><span class="c1">// Good: Even in the function body, &quot;#&quot; is at the beginning of the line.</span>
        <span class="n">WriteToSysLog</span><span class="p">();</span>
<span class="cp">#else</span>
        <span class="n">WriteToFileLog</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The nested preprocessor directives starting with <code class="docutils literal notranslate"><span class="pre">#</span></code> can be indented
and aligned based on a standardized style.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="cp">#if defined(__x86_64__) &amp;&amp; defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16)</span>
      <span class="cp">#define ATOMIC_X86_HAS_CMPXCHG16B 1 </span><span class="c1">// Good: wrapped for easier comprehension</span>
  <span class="cp">#else</span>
      <span class="cp">#define ATOMIC_X86_HAS_CMPXCHG16B 0</span>
  <span class="cp">#endif</span>

<span class="n">Whitespace</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-14-1-ensure-that-horizontal-spaces-are-used-to-highlight-keywords-and-important-information-and-avoid-unnecessary-whitespace">
<h3>Rule 3.14.1 Ensure that horizontal spaces are used to highlight keywords and important information, and avoid unnecessary whitespace.<a class="headerlink" href="#rule-3-14-1-ensure-that-horizontal-spaces-are-used-to-highlight-keywords-and-important-information-and-avoid-unnecessary-whitespace" title="Permalink to this headline">¶</a></h3>
<p>Horizontal spaces are used to highlight keywords and important
information. Spaces are not allowed at the end of each code line. The
general rules are as follows:</p>
<ul class="simple">
<li><p>Add spaces after keywords such as if, switch, case, do, while, and
for.</p></li>
<li><p>Do not add spaces after the left parenthesis or before the right
parenthesis.</p></li>
<li><p>For expressions enclosed by braces, either add a space on either side
or avoid a space on either side.</p></li>
<li><p>Do not add spaces after any unary operator (&amp; * + - ~ !).</p></li>
<li><p>Add a space to the left and right sides of each binary operator (= +
-&lt; &gt; * /% | &amp; ^ &lt;= &gt;= == !=).</p></li>
<li><p>Add spaces to the left and right sides of a ternary operator (? :).</p></li>
<li><p>Do not add spaces between a prefix or suffix increment (++) or
decrement (–) operator and a variable.</p></li>
<li><p>Do not add spaces before or after a struct member operator (. -&gt;).</p></li>
<li><p>Do not add spaces before commas. Add spaces after commas.</p></li>
<li><p>Do not add spaces between a template or type conversion operator (&lt;&gt;)
and a type.</p></li>
<li><p>Do not add spaces before or after a domain operator (::).</p></li>
<li><p>Determine whether to add spaces before and after a colon (:) based on
the actual situation.</p></li>
</ul>
<p>In normal cases:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Good: A space is added before the left brace.</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Good: During variable initialization, there should be spaces before and after =. Do not leave a space before the semicolon.</span>

<span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// Good: Spaces are not added in braces.</span>
</pre></div>
</div>
<p>Function definition and call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="n">arg2</span><span class="p">);</span>
                    <span class="o">^</span>    <span class="c1">// Bad: A space should be added after the comma.</span>

<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="p">);</span>
                 <span class="o">^</span>          <span class="o">^</span>  <span class="c1">// Bad: Spaces should not be added after the left parenthesis or before the right parenthesis.</span>
</pre></div>
</div>
<p>Pointer and Address Operator</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="c1">// Good: There is no space between the operator * and the pointer p.</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>     <span class="c1">// Good: There is no space between the operator &amp; and the variable x.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>    <span class="c1">// Good: When a member variable is accessed through the operator (.), no space is added.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>   <span class="c1">// Good: When a member variable is accessed through the operator (-&gt;), no space is added.</span>
</pre></div>
</div>
<p>Other Operators:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Good: There is a space before and after the assignment operator (=).</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">-5</span><span class="p">;</span>  <span class="c1">// Good: There is no space between the minus sign (–) and the number.</span>
<span class="o">++</span><span class="n">x</span><span class="p">;</span>     <span class="c1">//Good: Do not add spaces between a prefix or suffix increment (++) or decrement (--) operator and a variable..</span>
<span class="n">x</span><span class="o">--</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="p">)</span> <span class="c1">// Good: There is a space before and after the Boolean operator. There is no space between the ! operator and the variable.</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">;</span>  <span class="c1">// Good: There is a space before and after the binary operator.</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>    <span class="c1">// Good: There is no space before or after the expression in the parentheses.</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// Good: Ternary operator. There is a space before and after ? and :</span>
</pre></div>
</div>
<p>Loops and Conditional Statements:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Good: There is a space between the if keyword and the left parenthesis, and no space before or after the conditional statement in the parentheses.</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>           <span class="c1">// Good: There is a space between the else keyword and the left brace.</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">while</span> <span class="p">(</span><span class="n">conditions</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">// Good: There is a space between the while keyword and the left parenthesis. There is no space before or after the conditional statement in the parentheses.</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">someRange</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Good: There is a space between the for keyword and the left parenthesis, and after the semicolon.</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Good: There is a space after the switch keyword.</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>     <span class="c1">// Good: There is no space between the case condition and the colon.</span>
        <span class="p">...</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="p">...</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Templates and Conversions</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Angle brackets (&lt; and &gt;) are not adjacent to space. There is no space before &lt; or between &gt; and (.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="c1">// There can be a space between the type and the pointer operator. Keep the spacing style consistent.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
<p>Scope Operators</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>    <span class="c1">// Good: Namespace access. Do not leave spaces.</span>

<span class="kt">int</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span>  <span class="c1">// Good: Do not leave spaces in the definition of member functions.</span>
</pre></div>
</div>
<p>Colons</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Scenarios when space is required</span>

<span class="c1">// Good: // Add a space before or after the colon in a derived class definition.</span>
<span class="k">class</span> <span class="nc">Sub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>

<span class="p">};</span>

<span class="c1">// Add a space before or after the colon in the initialization list of a constructor function.</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">someVar_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Add a space before or after the colon in a bit-field.</span>
<span class="k">struct</span> <span class="nc">XX</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="nl">a</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
    <span class="kt">char</span> <span class="nl">b</span> <span class="p">:</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Scenarios when space is not required</span>

<span class="c1">// Good: // No space is added before or after the colon next to a class access permission (public or private).</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">someVar_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// No space is added before or after the colon in a switch statement.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="n">DoSomething</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note: Currently, all IDEs support automatic deletion of spaces at the
end of a line. Please configure your IDE correctly.</p>
</div>
<div class="section" id="recommendation-3-14-1-use-blank-lines-only-when-necessary-to-keep-code-compact">
<h3>Recommendation 3.14.1 Use blank lines only when necessary to keep code compact.<a class="headerlink" href="#recommendation-3-14-1-use-blank-lines-only-when-necessary-to-keep-code-compact" title="Permalink to this headline">¶</a></h3>
<p>There must be as few blank lines as possible so that more code can be
displayed for easy reading. Recommendations: - Add blank lines according
to the correlation between lines. - Consecutive blank lines are not
allowed inside functions, type definitions, macros, and initialization
expressions. - A maximum of <strong>two</strong> consecutive blank lines can be used.
- Do not add blank lines on the first and last lines of a code block in
braces. This recommendation is not applicable to code block in braces of
a namespace.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="kt">int</span> <span class="nf">Foo</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>



  <span class="kt">int</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span><span class="c1">// Bad: More than one blank lines are used between two function definitions.</span>
  <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>


  <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
          <span class="c1">// Bad: Do not add blank lines on the first and last lines of a code block.</span>
      <span class="p">...</span>
          <span class="c1">// Bad: Do not add blank lines on the first and last lines of a code block.</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">Foo</span><span class="p">(...)</span>
  <span class="p">{</span>
          <span class="c1">// Bad: Do not add blank lines before the first statement in a function body.</span>
      <span class="p">...</span>
  <span class="p">}</span>

<span class="n">Classes</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-3-15-1-class-access-specifier-declarations-are-in-the-sequence-public-protected-private-indent-these-specifiers-to-the-same-level-as-the-class-keyword">
<h3>Rule 3.15.1 Class access specifier declarations are in the sequence: public, protected, private. Indent these specifiers to the same level as the class keyword.<a class="headerlink" href="#rule-3-15-1-class-access-specifier-declarations-are-in-the-sequence-public-protected-private-indent-these-specifiers-to-the-same-level-as-the-class-keyword" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>      <span class="c1">// Not indented.</span>
    <span class="n">MyClass</span><span class="p">();</span>  <span class="c1">// Indented with 4 spaces.</span>
    <span class="k">explicit</span> <span class="nf">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">SomeFunction</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">SomeFunctionThatDoesNothing</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">SetVar</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span> <span class="n">someVar_</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">GetVar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">someVar_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">SomeInternalFunction</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">someVar_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">someOtherVar_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In each part, it is recommended that similar statements be put together
and in the following order: Type (including typedef, using, nested
structs and classes), Constant, Factory Function, Constructor,
Assignment Operator, Destructor, Other Member Function, and Data Member</p>
</div>
<div class="section" id="rule-3-15-2-the-constructor-initialization-list-must-be-on-the-same-line-or-wrapped-and-aligned-with-four-spaces-of-indentation">
<h3>Rule 3.15.2 The constructor initialization list must be on the same line or wrapped and aligned with four spaces of indentation.<a class="headerlink" href="#rule-3-15-2-the-constructor-initialization-list-must-be-on-the-same-line-or-wrapped-and-aligned-with-four-spaces-of-indentation" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// If all variables can be placed on the same line</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">someVar_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// If the variables cannot be placed on the same line</span>
<span class="c1">// Wrapped at the colon and indented with four spaces</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">someVar_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">someOtherVar_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// Good: Add a space after the comma.</span>
<span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//  If an initialization list needs to be placed in multiple lines, put each member on a separate line and align between lines.</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="n">someVar</span><span class="p">(</span><span class="n">var</span><span class="p">),</span>             <span class="c1">// Four spaces of indentation.</span>
      <span class="n">someOtherVar_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="comments">
<h1>4 Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">Generally, clear architecture and good naming are recommended to
improve code readability, and comments are provided only when
necessary.</div>
<div class="line">Comments are used to help readers quickly understand code. Therefore,
<strong>comments should be provided for the sake of readers</strong>.</div>
</div>
<p>Comments must be concise, clear, and unambiguous, ensuring that
information is complete and not redundant.</p>
<div class="line-block">
<div class="line"><strong>Comments are as important as code</strong>.</div>
<div class="line">When writing a comment, you need to step into the reader’s shoes and
use comments to express what the reader really needs. Comments are
used to express the function and intention of code, rather than
repeating code.</div>
<div class="line">When modifying the code, ensure that the comments are consistent with
the modified code. It is not polite to modify only code and keep the
old comments, which will undermine the consistency between code and
comments, and may confuse or even mislead readers.</div>
</div>
<p>Comments should be made in English.</p>
<div class="section" id="comment-style">
<h2>Comment Style<a class="headerlink" href="#comment-style" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">In C++ code, both <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> and <code class="docutils literal notranslate"><span class="pre">//</span></code> can be used for commenting.</div>
<div class="line">Comments can be classified into different types, such as file header
comments, function header comments, and code comments. This is based
on their purposes and positions.</div>
<div class="line">Comments of the same type must keep a consistent style.</div>
</div>
<p>Note: Example code in this document uses comments in the <code class="docutils literal notranslate"><span class="pre">//</span></code> format
only to better describe the rules and recommendations. This does not
mean this comment format is better.</p>
<blockquote>
<div><p>File Header Comments</p>
</div></blockquote>
<hr class="docutils" />
<div class="section" id="rule-4-2-1-file-header-comments-must-contain-the-copyright-notice">
<h3>Rule 4.2.1 File header comments must contain the copyright notice.<a class="headerlink" href="#rule-4-2-1-file-header-comments-must-contain-the-copyright-notice" title="Permalink to this headline">¶</a></h3>
<p>/ Copyright (c) 2020 Huawei Device Co., Ltd. * Licensed under the
Apache License, Version 2.0 (the “License”); * you may not use this
file except in compliance with the License. * You may obtain a copy of
the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a> Unless
required by applicable law or agreed to in writing, software *
distributed under the License is distributed on an “AS IS” BASIS, *
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License. */</p>
<blockquote>
<div><p>Function Header Comments</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>Rule 4.3.1 Function header comments with no content are forbidden.</p>
</div></blockquote>
<hr class="docutils" />
<p>Not all functions need function header comments. For information that
cannot be described by function signatures, add function header
comments.</p>
<p>Function header comments are placed above the function declaration or
definition. Use one of the following styles: Use ‘//’ to start the
function header.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Single-line function header</span>
<span class="kt">int</span> <span class="nf">Func1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Multi-line function header</span>
<span class="c1">// Second line</span>
<span class="kt">int</span> <span class="nf">Func2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">/*</span>&#160;&#160; <span class="pre">*/</span></code> to start the function header.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Single-line function header */</span>
<span class="kt">int</span> <span class="nf">Func1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Another single-line function header</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">Func2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Multi-line function header</span>
<span class="cm"> * Second line</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">Func3</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Use function names to describe functions, and add function header
comments if necessary. Do not write useless or redundant function
headers. Do not write empty function headers with no content.</p>
<p>The function header comment content will depend on the function and
includes but is not limited to: a function description, return value,
performance constraints, usage comments, memory conventions, algorithm
implementation, reentering requirements. In the function interface
declaration in the external header file, the function header comment
should clearly describe important and useful information.</p>
<p>Good example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * The number of written bytes is returned. If -1 is returned, the write operation failed.</span>
<span class="cm"> * Note that the memory buffer should be released by the caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">WriteString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>Bad example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Function name: WriteString</span>
<span class="cm"> * Function: Write a character string.</span>
<span class="cm"> * Parameters:</span>
<span class="cm"> * Return value:</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">WriteString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</pre></div>
</div>
<p>Problems:</p>
<ul class="simple">
<li><p>The ‘Parameters’ and ‘Return value’ have no content.</p></li>
<li><p>The function name is redundant.</p></li>
<li><p>The most import thing, that is, who needs to release the buffer, is
not clearly stated.</p></li>
</ul>
<blockquote>
<div><p>Code Comments</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="rule-4-4-1-code-comments-are-placed-above-or-on-the-right-of-the-corresponding-code">
<h3>Rule 4.4.1 Code comments are placed above or on the right of the corresponding code.<a class="headerlink" href="#rule-4-4-1-code-comments-are-placed-above-or-on-the-right-of-the-corresponding-code" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="rule-4-4-2-there-must-be-a-space-between-the-comment-character-and-the-comment-content-at-least-one-space-is-required-between-the-comment-and-code-if-the-comment-is-placed-to-the-right-of-code">
<h3>Rule 4.4.2 There must be a space between the comment character and the comment content. At least one space is required between the comment and code if the comment is placed to the right of code.<a class="headerlink" href="#rule-4-4-2-there-must-be-a-space-between-the-comment-character-and-the-comment-content-at-least-one-space-is-required-between-the-comment-and-code-if-the-comment-is-placed-to-the-right-of-code" title="Permalink to this headline">¶</a></h3>
<p>Comments placed above code should be indented the same as that of the
code. Use one of the following styles: Use “//”.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Single-line comment</span>
<span class="n">DoSomething</span><span class="p">();</span>

<span class="c1">// Multi-line comment</span>
<span class="c1">// Second line</span>
<span class="n">DoSomething</span><span class="p">();</span>
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Single-line comment */</span>
<span class="n">DoSomething</span><span class="p">();</span>

<span class="cm">/*</span>
<span class="cm"> * Multi-line comment in another mode</span>
<span class="cm"> * Second line</span>
<span class="cm"> */</span>
<span class="n">DoSomething</span><span class="p">();</span>
</pre></div>
</div>
<p>Leave at least one space between the code and the comment on the right.
It is recommended that no more than four spaces be left. You can use the
Tab key to indent 1–4 spaces.</p>
<p>Select and use one of the following styles:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// Comment on the right</span>
<span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>  <span class="cm">/* Comment on the right */</span>
</pre></div>
</div>
<p>It is more appealing sometimes when the comment is placed on the right
of code and the comments and code are aligned vertically. After the
alignment, ensure that the comment is 1–4 spaces away from the widest
line of code. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">A_CONST</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>         <span class="cm">/* Related comments of the same type can be aligned vertically. */</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ANOTHER_CONST</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>   <span class="cm">/* Leave spaces after code to align comments vertically. */</span>
</pre></div>
</div>
<p>When the comment on the right exceeds the line width, consider placing
the comment above the code.</p>
</div>
<div class="section" id="rule-4-4-3-delete-unused-code-segments-do-not-comment-them-out">
<h3>Rule 4.4.3 Delete unused code segments. Do not comment them out.<a class="headerlink" href="#rule-4-4-3-delete-unused-code-segments-do-not-comment-them-out" title="Permalink to this headline">¶</a></h3>
<p>Code that is commented out cannot be maintained. If you attempt to
restore the code, it is very likely to introduce ignorable defects. The
correct method is to delete unnecessary code directly. If necessary,
consider porting or rewriting the code.</p>
<p>Here, commenting out refers to the removal of code from compilation
without actually deleting it. This is done by using /* */, //, #if 0,
#ifdef NEVER_DEFINED, and so on.</p>
</div>
<div class="section" id="recommendation-4-4-1-delivered-code-cannot-contain-a-todo-tbd-fixme-comment">
<h3>Recommendation 4.4.1 Delivered code cannot contain a TODO/TBD/FIXME comment.<a class="headerlink" href="#recommendation-4-4-1-delivered-code-cannot-contain-a-todo-tbd-fixme-comment" title="Permalink to this headline">¶</a></h3>
<p>TODO/TBD comments are used to describe required improvements and
supplements. FIXME comments are used to describe defects that need
fixing. They should have a standardized style, which facilitates text
search. For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// TODO(&lt;author-name&gt;): XX</span>
<span class="c1">// FIXME: XX</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="header-files">
<h1>5 Header Files<a class="headerlink" href="#header-files" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Header File Responsibility</p>
</div></blockquote>
<hr class="docutils" />
<p>A header file is an external interface of a module or file. The design
of a header file shows most of the system design. The interface
declaration for most functions is more suitable placed in the header
file, but implementation (except inline functions) cannot be placed in
the header file. Functions, macros, enumerations, and structure
definitions that need to be used in .cpp files cannot be placed in the
header file. The header responsibility should be simple. An overly
complex header file will make dependencies complex and cause long
compilation times.</p>
<p>Generally, each .cpp file has a corresponding .h file. This .cpp file is
used to store the function declarations, macro definitions, and class
definitions that are to be exposed. If a .cpp file does not need to open
any interface externally, it should not exist. Exception: <strong>An entry
point (for example, the file where the main function is located), unit
tests, and dynamic libraries</strong></p>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Foo.h</span>

<span class="cp">#ifndef FOO_H</span>
<span class="cp">#define FOO_H</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">Fun</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Foo.cpp</span>
  <span class="cp">#include</span> <span class="cpf">&quot;Foo.h&quot;</span><span class="cp"></span>

  <span class="k">namespace</span> <span class="p">{</span> <span class="c1">// Good: The declaration of the internal function is placed in the header of the .cpp file, and has been limited to the unnamed namespace or static scope.</span>
      <span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span>
      <span class="p">{</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">...</span>

  <span class="kt">void</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Fun</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">Bar</span><span class="p">();</span>
  <span class="p">}</span>

<span class="n">Header</span> <span class="n">File</span> <span class="n">Dependency</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="line-block">
<div class="line">An example of cyclic dependency (also known as circular dependency)
is: a.h contains b.h, b.h contains c.h, and c.h contains a.h. If any
of these header files is modified, all code containing a.h, b.h, and
c.h needs to be recompiled.</div>
<div class="line">For a unidirectional dependency, for example if: a.h contains b.h, b.h
contains c.h, and c.h does not contain any header file, modifying a.h
does not mean that we need to recompile the source code for b.h or
c.h.</div>
</div>
<p>The cyclic dependency of header files reflects an obviously unreasonable
architecture design, which can be avoided through optimization.</p>
<p>To prevent header files from being included multiple times, all header
files should be protected by #define. Do not use #pragma once.</p>
<p>When defining a protection character, comply with the following rules:
1) The protection character uses a unique name. 2) Do not place code or
comments (except for file header comments) before or after the protected
part.</p>
<p>Example: Assume that the timer.h file of the timer module is in the
timer/include/timer.h directory. Perform the following operations to
safeguard the timer.h file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef TIMER_INCLUDE_TIMER_H</span>
<span class="cp">#define TIMER_INCLUDE_TIMER_H</span>
<span class="p">...</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Interfaces provided by other modules or files can be used only by
including header files. Using external function interfaces and variables
in extern declaration mode may cause inconsistency between declarations
and definitions when external interfaces are changed. In addition, this
kind of implicit dependency may cause architecture corruption.</p>
<p>Cases that do not comply with specifications:</p>
<p>// a.cpp content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kt">int</span> <span class="n">Fun</span><span class="p">();</span>   <span class="c1">// Bad: Use external functions in extern mode.</span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Fun</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>// b.cpp content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">Fun</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Do something</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Should be changed to:</p>
<p>// a.cpp content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;b.h&quot;</span><span class="c1">   // Good: Use the interface provided by other .cpp by including its corresponding header file.</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Fun</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>// b.h content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">Fun</span><span class="p">();</span>
</pre></div>
</div>
<p>// b.cpp content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">Fun</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Do something</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In some scenarios, if internal functions need to be referenced with no
intrusion to the code, the extern declaration mode can be used. For
example: When performing unit testing on an internal function, you can
use the extern declaration to reference the tested function. When a
function needs to be stubbed or patched, the function can be declared
using extern.</p>
<p>If a header file is included in extern “C”, extern “C” may be nested.
Some compilers restrict the nesting of extern “C”. If there are too many
nested layers, compilation errors may occur.</p>
<p>When C and C++ programmings are used together and if extern “C” includes
a header file, the original intent behind the header file may be
hindered. For example, when the link specifications are modified
incorrectly.</p>
<p>For example, assume that there are two header files a.h and b.h.</p>
<p>// a.h content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="cp">#define A(value) Foo(value)</span>
<span class="cp">#else</span>
<span class="kt">void</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>// b.h content</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&quot;a.h&quot;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">B</span><span class="p">();</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Using the C++ preprocessor to expand b.h, the following information is
displayed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">B</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>According to the author of a.h, the function Foo is a C++ free function
following the “C++” link specification. However, because
<code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;a.h&quot;</span></code> is placed inside <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> in b.h, the link
specification of function Foo is changed incorrectly.</p>
<p>Exception: In the C++ compilation environment, if you want to reference
the header file of pure C, the C header files should not contain
<code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code>. The non-intrusive approach is to include the C header
file in <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code>.</p>
<p>A forward declaration is for the declaration of classes, functions, and
templates and is not meant for its definition.</p>
<ul class="simple">
<li><p>Advantages:</p>
<ol class="arabic simple">
<li><p>Forward declarations can save compilation time. Redundant
<code class="docutils literal notranslate"><span class="pre">#include</span></code>statements force the compiler to expand more files
and process more input.</p></li>
<li><p>Forward declarations can save unnecessary recompilation time. The
use of #include will force your code to be recompiled multiple
times due to unrelated changes in header files.</p></li>
</ol>
</li>
<li><p>Disadvantages:</p>
<ol class="arabic simple">
<li><p>Forward declarations hide dependency relationship. When a header
file is modified, user code will skip the necessary recompilation
process.</p></li>
<li><p>A forward declaration may be broken by subsequent changes to the
library. Forward declarations of functions and templates sometimes
prevent header file developers from changing APIs. For example,
widening a formal parameter type, adding a template parameter with
a default value, and so on.</p></li>
<li><p>Forward declaration of symbols from the namespace <code class="docutils literal notranslate"><span class="pre">std::</span></code> is
seen as undefined behavior (as specified in the C++ 11 standard
specification).</p></li>
<li><p>Forward declaration of multiple symbols from a header file can be
more verbose than simply including (#include) the header.</p></li>
<li><p>Structuring code only for forward declaration (for example, using
pointer members instead of object members) can make the code more
complex and slower.</p></li>
<li><p>It is difficult to determine whether a forward declaration or
<code class="docutils literal notranslate"><span class="pre">#include</span></code> is needed. In some scenarios, replacing <code class="docutils literal notranslate"><span class="pre">#include</span></code>
with a forward declaration may cause unexpected results.</p></li>
</ol>
</li>
</ul>
<p>Therefore, we should avoid using forward declarations as much as
possible. Instead, we use the #include statement to include a header
file and ensure dependency.</p>
</div>
<div class="section" id="scopes">
<h1>6 Scopes<a class="headerlink" href="#scopes" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Namespaces</p>
</div></blockquote>
<hr class="docutils" />
<p>In the C++ 2003 standard, using static to modify the external
availability of functions and variables was marked as deprecated.
Therefore, unnamed namespaces are the recommended method.</p>
<p>Main Reasons: 1. There are too many meanings for static in C++: static
function member variable, static member function, static global
variable, and static function local variable. Each of them has special
processing. 2. Static can only be used to define variables, constants,
and functions that are not referenced outside the current .cpp file,
while namespaces can also be used to encapsulate types. 3. Use a
namespace to control the scope instead of using both static and
namespaces. 4. Unnamed namespaces can be used to instantiate templates
rather than functions modified by the static keyword.</p>
<p>Do not use unnamed namespaces or static in header files.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Foo.cpp</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_COUNT</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">InternalFun</span><span class="p">(){};</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Fun</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">MAX_COUNT</span><span class="p">;</span>

    <span class="n">InternalFun</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note: Using “using” to import namespace will affect any subsequent code
and may cause symbol conflicts. Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Header file a.h</span>
<span class="k">namespace</span> <span class="n">NamespaceA</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Header file b.h</span>
<span class="k">namespace</span> <span class="n">NamespaceB</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">NamespaceB</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">G</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Fun</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Source code a.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;a.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">NamespaceA</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&quot;b.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">G</span><span class="p">();</span> <span class="c1">// &quot;using namespace NamespaceA&quot; before #include &quot;b.h&quot;, will cause conflicts when calling NamespaceA::Fun and NamespaceB::Fun.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Using “using” to import a symbol or define an alias in a header file is
allowed in customized namespaces of modules, but is prohibited in the
global namespace.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// foo.h</span>

  <span class="cp">#include</span> <span class="cpf">&lt;fancy/string&gt;</span><span class="cp"></span>
  <span class="k">using</span> <span class="n">fancy</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>  <span class="c1">// Bad: It is prohibited to import symbols to the global namespace.</span>

  <span class="k">namespace</span> <span class="n">Foo</span> <span class="p">{</span>
      <span class="k">using</span> <span class="n">fancy</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>  <span class="c1">// Good: Symbols can be imported in customized namespaces of modules.</span>
      <span class="k">using</span> <span class="n">MyVector</span> <span class="o">=</span> <span class="n">fancy</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>  <span class="c1">// Good: In C++11, aliases can be defined in customized namespaces.</span>
  <span class="p">}</span>

<span class="n">Global</span> <span class="n">Functions</span> <span class="n">and</span> <span class="n">Static</span> <span class="n">Member</span> <span class="n">Functions</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Note: Placing non-member functions in a namespace avoids polluting the
global scope. Do not use “class + static member function” to simply
manage global functions. If a global function is closely tied to a
class, it can be used as a static member function of the class.</p>
<p>If you need to define some global functions for a .cpp file, use unnamed
namespaces for management.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">class</span> <span class="nc">File</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">static</span> <span class="n">File</span> <span class="n">CreateTempFile</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileName</span><span class="p">);</span>
  <span class="p">};</span>

<span class="n">Global</span> <span class="n">Constants</span> <span class="n">and</span> <span class="n">Static</span> <span class="n">Member</span> <span class="n">Constants</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Note: Placing global constants in a namespace avoids polluting the
global scope. Do not use “class + static member constant” to simply
manage global constants. If a global constant is closely tied to a
class, it can be used as a static member constant of the class.</p>
<p>If you need to define some global constants only for a .cpp file, use
unnamed namespaces for management.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">class</span> <span class="nc">File</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SEPARATOR</span><span class="p">;</span>
  <span class="p">};</span>

<span class="n">Global</span> <span class="n">Variables</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Note: Global variables can be modified and read, which results in data
coupling between production code and the global variables.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">g_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// a.cpp</span>
<span class="n">g_counter</span><span class="o">++</span><span class="p">;</span>

<span class="c1">// b.cpp</span>
<span class="n">g_counter</span><span class="o">++</span><span class="p">;</span>

<span class="c1">// c.cpp</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g_counter</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Singleton</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Counter</span><span class="o">&amp;</span> <span class="n">GetInstance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">Counter</span> <span class="n">counter</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
    <span class="p">}</span>  <span class="c1">// Simple example of a singleton implementation</span>

    <span class="kt">void</span> <span class="n">Increase</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">value_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Print</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Counter</span><span class="p">()</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// a.cpp</span>
<span class="n">Counter</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">().</span><span class="n">Increase</span><span class="p">();</span>

<span class="c1">// b.cpp</span>
<span class="n">Counter</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">().</span><span class="n">Increase</span><span class="p">();</span>

<span class="c1">// c.cpp</span>
<span class="n">Counter</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">().</span><span class="n">Print</span><span class="p">();</span>
</pre></div>
</div>
<p>After the singleton is implemented, there is a unique global instance,
which can functions as a global variable. However, the singleton
provides better encapsulation.</p>
<p>Exception: In some cases, the scope of a global variable is contained
inside a module. Multiple instances of the same global variable may
exist, and each module holds one copy. In this case, a singleton cannot
be used as it is limited to one instance.</p>
</div>
<div class="section" id="classes">
<span id="classes-1"></span><h1>7 Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Constructors, Copy/Move Constructors, Copy/Move Assignment Operators, and Destructors</p>
</div></blockquote>
<hr class="docutils" />
<div class="line-block">
<div class="line">Constructors, copy/move constructors, copy/move assignment operators,
and destructors provide lifetime management methods for objects. -
Constructor: <code class="docutils literal notranslate"><span class="pre">X()</span></code> - Copy constructor: <code class="docutils literal notranslate"><span class="pre">X(const</span> <span class="pre">X&amp;)</span></code> - Copy
assignment operator: <code class="docutils literal notranslate"><span class="pre">operator=(const</span> <span class="pre">X&amp;)</span></code></div>
<div class="line">- Move constructor: <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">(X&amp;&amp;)</span></code> <em>Provided in versions later than C++
11</em>. - Move assignment operator: <code class="docutils literal notranslate"><span class="pre">operator=(X&amp;&amp;)</span></code> <em>Provided in
versions later than C++ 11</em>. - Destructor: <code class="docutils literal notranslate"><span class="pre">~X()</span></code></div>
</div>
<p>Note: If a class has members but no constructor and a default
constructor is defined, the compiler will automatically generate a
constructor, but it will not initialize member variables. The content of
each object is uncertain.</p>
<p>Exception: - If the member variables in a class have a default
constructor, explicit initialization is not required.</p>
<p>Example: The following code has no constructor, and private data members
cannot be initialized:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">ProcessOutMsg</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//…</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msgID_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msgLength_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msgBuffer_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">someIdentifier_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Message</span> <span class="n">message</span><span class="p">;</span>   <span class="c1">// The message member is not initialized.</span>
<span class="n">message</span><span class="p">.</span><span class="n">ProcessOutMsg</span><span class="p">();</span>   <span class="c1">// Potential risks exist in subsequent use.</span>

<span class="c1">// Therefore, it is necessary to define a default constructor as follows:</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Message</span><span class="p">()</span> <span class="o">:</span> <span class="n">msgID_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">msgLength_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">msgBuffer_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">ProcessOutMsg</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// …</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msgID_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msgLength_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msgBuffer_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">someIdentifier</span><span class="p">;</span> <span class="c1">// The member variable has a default constructor. Therefore, explicit initialization is not required.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note: Initialization during declaration (C++11) is preferred because
initialized values of member variables can be easily understood. If
initialized values of certain member variables are relevant to
constructors, or C++ 11 is not supported, the constructor initialization
list is used preferentially to initialize these member variables.
Compared with the assignment statements in constructors, code of the
constructor initialization list is simpler and has higher performance,
and can be used to initialize constant and reference members.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Message</span><span class="p">()</span> <span class="o">:</span> <span class="n">msgLength</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Good: The constructor initialization list is preferred.</span>
    <span class="p">{</span>
        <span class="n">msgBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>     <span class="c1">// Bad: Values cannot be assigned in constructors.</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msgID</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>  <span class="c1">// Good: Used in C++11.</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msgLength_</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msgBuffer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note: If a single-parameter constructor is not declared as explicit, it
will become an implicit conversion function. Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">ProcessFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">){}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span><span class="p">;</span>
    <span class="n">ProcessFoo</span><span class="p">(</span><span class="n">test</span><span class="p">);</span>  <span class="c1">// Compiling failed.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The preceding code fails to be compiled because the parameter required
by <code class="docutils literal notranslate"><span class="pre">ProcessFoo</span></code> is of the Foo type, which mismatch with the input
string type.</p>
<p>If the explicit keyword of the Foo constructor is removed, implicit
conversion is triggered and a temporary Foo object is generated when
<code class="docutils literal notranslate"><span class="pre">ProcessFoo</span></code> is called with the string parameter. Usually, this
implicit conversion is confusing and bugs are apt to be hidden, due to
unexpected type conversion. Therefore, single-parameter constructors
require explicit declaration.</p>
<p>Note: If users do not define it, the compiler will generate copy
constructors and copy assignment operators, move constructors and move
assignment operators (move semantic functions will be available in
versions later than C++ 11). If we do not use copy constructors or copy
assignment operators, explicitly delete them.</p>
<ol class="arabic simple">
<li><p>Set copy constructors or copy assignment operators to private and do
not implement them.</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Use delete provided by C++ 11. For details, see Rule 10.1.3 in
chapter 10 Modern C++ Features.</p></li>
</ol>
<p>Both copy constructors and copy assignment operators provide copy
semantics. They should be implemented or hidden together.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The copy constructor and the copy assignment operator are implemented together.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// The copy constructor and the copy assignment operator are both set to default, as supported by C++ 11.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The copy constructor and the copy assignment operator are hidden together. You should use the delete keyword if C++11 features are available.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The move operation is added in C++ 11. If a class is required to support
the move operation, move constructors and move assignment operators need
to be implemented.</p>
<p>Both move constructors and move assignment operators provide move
semantics. They should be implemented or hidden together.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The copy constructor and the copy assignment operator are implemented together.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
    <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">);</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// The copy constructor and the copy assignment operator are both set to default, as supported by C++ 11.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The copy constructor and the copy assignment operator are hidden together. You should use the delete keyword if C++11 features are available.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note: Calling a virtual function of the current object in a constructor
or destructor will cause behaviors of non-polymorphism. In C++, a base
class constructs only one complete object at a time.</p>
<p>Example: Base indicates the base class, and Sub indicates the derived
class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Log</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// Different derived classes call different log files.</span>
<span class="p">};</span>

<span class="n">Base</span><span class="o">::</span><span class="n">Base</span><span class="p">()</span>         <span class="c1">// Base class constructor</span>
<span class="p">{</span>
    <span class="n">Log</span><span class="p">();</span>           <span class="c1">// Call the virtual function log.</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Sub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Log</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When running the following statement: <code class="docutils literal notranslate"><span class="pre">Sub</span> <span class="pre">sub;</span></code> The constructor of
the derived class is executed first. However, the constructor of the
base class is called first. Because the constructor of the base class
calls the virtual function log, the log is in the base class version.
The derived class is constructed only after the base class is
constructed. As a result, behaviors of non-polymorphism are caused. This
also applies to destructors.</p>
<blockquote>
<div><p>Inheritance</p>
</div></blockquote>
<hr class="docutils" />
<p>Note: Destructors of the derived class can be called during polymorphism
invocation only when destructors of the base class are virtual.</p>
<p>Example: There will be memory leak if destructors of the base class are
not declared as virtual.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getVersion</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="o">~</span><span class="n">Base</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;~Base&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Sub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sub</span><span class="p">()</span> <span class="o">:</span> <span class="n">numbers_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">Sub</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">numbers_</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;~Sub&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">Init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">numberCount</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">numbers_</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">[</span><span class="n">numberCount</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">...</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getVersion</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;hello!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">numbers_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sub</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because destructors of the base class are not declared as virtual, only
destructors of the base class are called when an object is destroyed.
Destructors of the derived class Sub are not called. As a result, a
memory leak occurs.</p>
<p>Note: In C++, virtual functions are dynamically bound, but the default
parameters of functions are statically bound during compilation. This
means that the function you finally execute is a virtual function that
is defined in the derived class but uses the default parameter value in
the base class. To avoid confusion and other problems caused by
inconsistent default parameter declarations during overriding of virtual
functions, it is prohibited to declare default parameter values for all
virtual functions. Example: The default value of parameter “text” of the
virtual function “Display” is determined at compilation time instead of
runtime, which does not fit with polymorphism.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Display</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;Base!&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Sub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Display</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">text</span>  <span class="o">=</span> <span class="s">&quot;Sub!&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">Sub</span><span class="p">(){}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Base</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sub</span><span class="p">();</span>
    <span class="n">Sub</span><span class="o">*</span> <span class="n">sub</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sub</span><span class="p">();</span>

    <span class="p">...</span>

    <span class="n">base</span><span class="o">-&gt;</span><span class="n">Display</span><span class="p">();</span>  <span class="c1">// The program output is as follows: Base! The expected output is as follows: Sub!</span>
    <span class="n">sub</span><span class="o">-&gt;</span><span class="n">Display</span><span class="p">();</span>   <span class="c1">// The program output is as follows: Sub!</span>

    <span class="k">delete</span> <span class="n">base</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">sub</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note: Non-virtual functions cannot be dynamically bound (only virtual
functions can be dynamically bound). You can obtain the correct result
by operating on the pointer of the base class.</p>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">Fun</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">Sub</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">Fun</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="n">Sub</span><span class="o">*</span> <span class="n">sub</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sub</span><span class="p">();</span>
  <span class="n">Base</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>

  <span class="n">sub</span><span class="o">-&gt;</span><span class="n">Fun</span><span class="p">();</span>    <span class="c1">// Call Fun of the derived class.</span>
  <span class="n">base</span><span class="o">-&gt;</span><span class="n">Fun</span><span class="p">();</span>   <span class="c1">// Call Fun of the base class.</span>
  <span class="c1">//...</span>

<span class="n">Multiple</span> <span class="n">Inheritance</span>
</pre></div>
</div>
<hr class="docutils" />
<p>In the actual development process, multiple inheritance is seldom used
because the following typical problems may occur: 1. Data duplication
and name ambiguity caused by “diamond” inheritance. C++ introduces
virtual inheritance to solve these problems. 2. In addition to “diamond”
inheritance, names of multiple base classes may also conflict with each
other, resulting in name ambiguity. 3. If a derived class needs to be
extended or needs to override methods of multiple base classes, the
responsibilities of the derived classes are unclear and semantics are
muddled. 4. Compared with delegation, inheritance is seen as white box
reuse, that is, a derived class can access the protected members of the
base class, which leads to more coupling. Multiple inheritance, due to
the coupling of multiple base classes, leads to even more coupling.</p>
<p>Multiple inheritance has the following advantages: Multiple inheritance
provides a simpler method for assembling and reusing multiple interfaces
or classes.</p>
<p>Therefore, multiple inheritance can be used only in the following cases:</p>
<p>If a class requires multiple interfaces, combine multiple separated
interfaces by using multiple inheritance. This is similar to the Traits
mixin of the Scala language.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Role1</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Role2</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Role3</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">Object1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Role1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Role2</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Object2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Role2</span><span class="p">,</span> <span class="k">public</span> <span class="n">Role3</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The C++ standard library has a similar implementation example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="k">class</span> <span class="nc">basic_istream</span> <span class="p">{};</span>
  <span class="k">class</span> <span class="nc">basic_ostream</span> <span class="p">{};</span>

  <span class="k">class</span> <span class="nc">basic_iostream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">basic_istream</span><span class="p">,</span> <span class="k">public</span> <span class="n">basic_ostream</span> <span class="p">{</span>

  <span class="p">};</span>

<span class="n">Overloading</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Overload operators should be used when there are sufficient reasons, and
they do not change the original perception of the operators. For
example, do not use the plus sign (+) to perform subtraction. Operator
overloading can make code more intuitive but has some disadvantages: -
It is often mistaken that the operation is as fast as a built-in
operator, which has no performance degradation. - There is no naming to
aid debugging. It is more convenient to search by function name than by
operator. - Overloading operators can cause confusion if behavior
definitions are not intuitive (for example, if the “+” operator is used
for subtraction). - The implicit conversion caused by the overloading of
assignment operators may lead to entrenched bugs. Functions such as
Equals () and CopyFrom () can be defined to replace the = and ==
operators.</p>
<blockquote>
<div><p>8 Functions</p>
</div></blockquote>
<hr class="docutils" />
<div class="section" id="function-design">
<h2>Function Design<a class="headerlink" href="#function-design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rule-8-1-1-avoid-long-functions-and-ensure-that-each-function-contains-no-more-than-50-lines-non-null-and-non-comment">
<h3>Rule 8.1.1 Avoid long functions and ensure that each function contains no more than 50 lines (non-null and non-comment).<a class="headerlink" href="#rule-8-1-1-avoid-long-functions-and-ensure-that-each-function-contains-no-more-than-50-lines-non-null-and-non-comment" title="Permalink to this headline">¶</a></h3>
<p>A function should be displayed on one screen (no longer than 50 lines).
It should do only one thing, and do it well.</p>
<p>Long functions often mean that the functions are too complex to
implement in more than one function, or overly detailed but not further
abstracted.</p>
<p>Exception: Some algorithms may be longer than 50 lines due to algorithm
convergence and functional comprehensiveness.</p>
<p>Even if a long function works very well now, once someone modifies it,
new problems may occur. It might even cause bugs that are difficult to
find. It is recommended that you split a long function into several
functions that are simpler and easier to manage, facilitating
comprehension and modification.</p>
</div>
</div>
<div class="section" id="inline-functions">
<h2>Inline Functions<a class="headerlink" href="#inline-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="recommendation-8-2-1-an-inline-function-cannot-exceed-10-lines">
<h3>Recommendation 8.2.1 An inline function cannot exceed 10 lines.<a class="headerlink" href="#recommendation-8-2-1-an-inline-function-cannot-exceed-10-lines" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: An inline function has the same characteristics of a normal
function. The difference between an inline function and a normal
function lies in the processing of function calls. When a general
function is called, the program execution right is transferred to the
called function, and then returned to the function that calls it. When
an inline function is called, the invocation expression is replaced with
an inline function body.</p>
<p>Inline functions are only suitable for small functions with only 1-10
lines. For a large function that contains many statements, the function
call and return overheads are relatively trivial and do not need the
help of an inline function. Most compilers may abandon the inline mode
and use the common method to call the function.</p>
<p>If an inline function contains complex control structures, such as loop,
branch (switch), and try-catch statements, the compiler may regard the
function as a common function. <strong>Virtual functions and recursive
functions cannot be used as inline functions</strong>.</p>
<blockquote>
<div><p>Function Parameters</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-8-3-1-use-a-reference-instead-of-a-pointer-for-function-parameters">
<h3>Recommendation 8.3.1 Use a reference instead of a pointer for function parameters.<a class="headerlink" href="#recommendation-8-3-1-use-a-reference-instead-of-a-pointer-for-function-parameters" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: A reference is more secure than a pointer because it is not
empty and does not point to other targets. Using a reference stops the
need to check for illegal null pointers.</p>
<p>If a product is being developed for an older platform, the processing
used by the old platform is preferred. Use const to avoid parameter
modification, so that readers can clearly know that a parameter is not
going to be modified. This greatly enhances code readability.</p>
<p>Exception: When the input parameter is an array with an unknown
compile-time length, you can use a pointer instead of a reference.</p>
</div>
<div class="section" id="recommendation-8-3-2-use-strongly-typed-parameters-do-not-use-void">
<h3>Recommendation 8.3.2 Use strongly typed parameters. Do not use void*.<a class="headerlink" href="#recommendation-8-3-2-use-strongly-typed-parameters-do-not-use-void" title="Permalink to this headline">¶</a></h3>
<p>While different languages have their own views on strong typing and weak
typing, it is generally believed that C and C++ are strongly typed
languages. Since we use such a strongly typed language, we should keep
to this style. An advantage of this is the compiler can find type
mismatch problems at the compilation stage.</p>
<p>Using strong typing helps the compiler find more errors for us. Pay
attention to the usage of the FooListAddNode function in the following
code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">FooNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">List</span> <span class="n">link</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">BarNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">List</span> <span class="n">link</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FooListAddNode</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="c1">// Bad: Here, the void * type is used to transfer parameters.</span>
<span class="p">{</span>
    <span class="n">FooNode</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">FooNode</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="p">;</span>
    <span class="n">ListAppend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g_FooList</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MakeTheList</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FooNode</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">BarNode</span> <span class="o">*</span><span class="n">bar</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="n">FooListAddNode</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>        <span class="c1">// Wrong: In this example, the foo parameter was supposed to be transferred, but the bar parameter is accidentally transferred instead. However, no error is reported.</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>You can use a template function to change the parameter type.</p></li>
<li><p>A base class pointer can be used to implement this according to
polymorphism.</p></li>
</ol>
</div>
<div class="section" id="recommendation-8-3-3-a-function-can-have-a-maximum-of-five-parameters">
<h3>Recommendation 8.3.3 A function can have a maximum of five parameters.<a class="headerlink" href="#recommendation-8-3-3-a-function-can-have-a-maximum-of-five-parameters" title="Permalink to this headline">¶</a></h3>
<p>If a function has too many parameters, it is apt to be affected by
external changes, and therefore maintenance is affected. Too many
function parameters will also increase the testing workload.</p>
<p>If a function has more than five parameters, you can: - Split the
function. - Combine related parameters into a struct.</p>
<blockquote>
<div><p>9 Other C++ Features</p>
</div></blockquote>
<hr class="docutils" />
<blockquote>
<div><p>Constants and Initialization</p>
</div></blockquote>
<hr class="docutils" />
<p>Unchanged values are easier to understand, trace, and analyze.
Therefore, use constants instead of variables as much as possible. When
defining values, use const as a default.</p>
</div>
<div class="section" id="rule-9-1-1-do-not-use-macros-to-replace-constants">
<h3>Rule 9.1.1 Do not use macros to replace constants.<a class="headerlink" href="#rule-9-1-1-do-not-use-macros-to-replace-constants" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: Macros are a simple text replacement that is completed in the
preprocessing phase. When an error is reported, the corresponding value
is reported. During tracing and debugging, the value is also displayed
instead of the macro name. A macro does not support type checking and is
insecure. A macro has no scope.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MAX_MSISDN_LEN 20    </span><span class="c1">// Bad</span>

<span class="c1">// Use const in C++.</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_MSISDN_LEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// Good</span>

<span class="c1">// In versions later than C++ 11, constexpr can be used.</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">MAX_MSISDN_LEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-9-1-1-a-group-of-related-integer-constants-must-be-defined-as-an-enumeration">
<h3>Recommendation 9.1.1 A group of related integer constants must be defined as an enumeration.<a class="headerlink" href="#recommendation-9-1-1-a-group-of-related-integer-constants-must-be-defined-as-an-enumeration" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: Enumerations are more secure than <code class="docutils literal notranslate"><span class="pre">#define</span></code> or
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span></code>. The compiler checks whether a parameter value is within
the enumerated value range to avoid errors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Good example:</span>
<span class="k">enum</span> <span class="nc">Week</span> <span class="p">{</span>
    <span class="n">SUNDAY</span><span class="p">,</span>
    <span class="n">MONDAY</span><span class="p">,</span>
    <span class="n">TUESDAY</span><span class="p">,</span>
    <span class="n">WEDNESDAY</span><span class="p">,</span>
    <span class="n">THURSDAY</span><span class="p">,</span>
    <span class="n">FRIDAY</span><span class="p">,</span>
    <span class="n">SATURDAY</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="nc">Color</span> <span class="p">{</span>
    <span class="n">RED</span><span class="p">,</span>
    <span class="n">BLACK</span><span class="p">,</span>
    <span class="n">BLUE</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">ColorizeCalendar</span><span class="p">(</span><span class="n">Week</span> <span class="n">today</span><span class="p">,</span> <span class="n">Color</span> <span class="n">color</span><span class="p">);</span>

<span class="n">ColorizeCalendar</span><span class="p">(</span><span class="n">BLUE</span><span class="p">,</span> <span class="n">SUNDAY</span><span class="p">);</span> <span class="c1">// Compilation error. The parameter type is incorrect.</span>

<span class="c1">// Bad example:</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">SUNDAY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MONDAY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">BLACK</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">BLUE</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">ColorizeCalendar</span><span class="p">(</span><span class="kt">int</span> <span class="n">today</span><span class="p">,</span> <span class="kt">int</span> <span class="n">color</span><span class="p">);</span>
<span class="n">ColorizeCalendar</span><span class="p">(</span><span class="n">BLUE</span><span class="p">,</span> <span class="n">SUNDAY</span><span class="p">);</span> <span class="c1">// No error is reported.</span>
</pre></div>
</div>
<p>When an enumeration value needs to correspond to a specific value,
explicit value assignment is required during declaration. Otherwise, do
not assign explicit values. This will prevent repeated assignment and
reduce the maintenance workload (when adding and deleting members).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Good example: Device ID defined in the S protocol. It is used to identify a device type.</span>
<span class="k">enum</span> <span class="nc">DeviceType</span> <span class="p">{</span>
    <span class="n">DEV_UNKNOWN</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">,</span>
    <span class="n">DEV_DSMP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">DEV_ISMG</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">DEV_WAPPORTAL</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Do not assign explicit values when enumeration is used internally, and
only for classification.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Good example: Enumeration definition is used to identify session status in a program.</span>
<span class="k">enum</span> <span class="nc">SessionState</span> <span class="p">{</span>
    <span class="n">INIT</span><span class="p">,</span>
    <span class="n">CLOSED</span><span class="p">,</span>
    <span class="n">WAITING_FOR_RESPONSE</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Try to avoid repeating enumeration values. If it is required, use the
already defined enumeration values instead.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">RTCPType</span> <span class="p">{</span>
    <span class="n">RTCP_SR</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">RTCP_MIN_TYPE</span> <span class="o">=</span> <span class="n">RTCP_SR</span><span class="p">,</span>
    <span class="n">RTCP_RR</span>    <span class="o">=</span> <span class="mi">201</span><span class="p">,</span>
    <span class="n">RTCP_SDES</span>  <span class="o">=</span> <span class="mi">202</span><span class="p">,</span>
    <span class="n">RTCP_BYE</span>   <span class="o">=</span> <span class="mi">203</span><span class="p">,</span>
    <span class="n">RTCP_APP</span>   <span class="o">=</span> <span class="mi">204</span><span class="p">,</span>
    <span class="n">RTCP_RTPFB</span> <span class="o">=</span> <span class="mi">205</span><span class="p">,</span>
    <span class="n">RTCP_PSFB</span>  <span class="o">=</span> <span class="mi">206</span><span class="p">,</span>
    <span class="n">RTCP_XR</span>  <span class="o">=</span> <span class="mi">207</span><span class="p">,</span>
    <span class="n">RTCP_RSI</span> <span class="o">=</span> <span class="mi">208</span><span class="p">,</span>
    <span class="n">RTCP_PUBPORTS</span> <span class="o">=</span> <span class="mi">209</span><span class="p">,</span>
    <span class="n">RTCP_MAX_TYPE</span> <span class="o">=</span> <span class="n">RTCP_PUBPORTS</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-9-1-2-magic-numbers-cannot-be-used">
<h3>Rule 9.1.2 Magic numbers cannot be used.<a class="headerlink" href="#rule-9-1-2-magic-numbers-cannot-be-used" title="Permalink to this headline">¶</a></h3>
<p>So-called magic numbers are numbers that are unintelligible and
difficult to understand.</p>
<p>Some numbers can be understood based on context. For example, the number
12 varies in different contexts. type = 12; is not intelligible (and a
magic number), but <code class="docutils literal notranslate"><span class="pre">month</span> <span class="pre">=</span> <span class="pre">year</span> <span class="pre">*</span> <span class="pre">12</span></code>; can be understood, so we
wouldn’t really class this as a magic number. The number 0 is often seen
as a magic number. For example, <code class="docutils literal notranslate"><span class="pre">status</span> <span class="pre">=</span> <span class="pre">0</span></code>; cannot truly express any
status information.</p>
<p>Solution: Comments can be added for numbers that are used locally. For
the numbers that are used multiple times, you must define them as
constants and give them descriptive names.</p>
<p>The following cases are forbidden: No symbol is used to explain the
meaning of a number, for example, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">ZERO</span> <span class="pre">=</span> <span class="pre">0</span></code>. The symbol
name limits the value. For example, for example,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">XX_TIMER_INTERVAL_300MS</span> <span class="pre">=</span> <span class="pre">300</span></code>. Use
<code class="docutils literal notranslate"><span class="pre">XX_TIMER_INTERVAL_MS</span></code> instead.</p>
</div>
<div class="section" id="rule-9-1-3-ensure-that-a-constant-has-only-one-responsibility">
<h3>Rule 9.1.3 Ensure that a constant has only one responsibility.<a class="headerlink" href="#rule-9-1-3-ensure-that-a-constant-has-only-one-responsibility" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: A constant is used for only one specific function, that is, a
constant cannot be used for multiple purposes.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Good example: For protocol A and protocol B, the length of the MSISDN is 20.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">A_MAX_MSISDN_LEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">B_MAX_MSISDN_LEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="c1">// Using different namespaces:</span>
<span class="k">namespace</span> <span class="n">Namespace1</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MAX_MSISDN_LEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Namespace2</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">MAX_MSISDN_LEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-9-1-4-do-not-use-memcpy-s-or-memset-s-to-initialize-non-pod-objects">
<h3>Rule 9.1.4 Do not use memcpy_s or memset_s to initialize non-POD objects.<a class="headerlink" href="#rule-9-1-4-do-not-use-memcpy-s-or-memset-s-to-initialize-non-pod-objects" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: <code class="docutils literal notranslate"><span class="pre">POD</span></code> is short for <code class="docutils literal notranslate"><span class="pre">Plain</span> <span class="pre">Old</span> <span class="pre">Data</span></code>, which is a concept
introduced in the C++ 98 standard (ISO/IEC 14882, first edition,
1998-09-01). The <code class="docutils literal notranslate"><span class="pre">POD</span></code> types include the original types and aggregate
types such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">enumeration</span></code>,
<code class="docutils literal notranslate"><span class="pre">void</span></code>, and pointer. Encapsulation and object-oriented features cannot
be used (for example, user-defined constructors, assignment operators,
destructors, base classes, and virtual functions).</p>
<p>For non-POD classes, such as class objects of non-aggregate types,
virtual functions may exist. Memory layout is uncertain, and is related
to the compiler. Misuse of memory copies may cause serious problems.</p>
<p>Even if a class of the aggregate type is directly copied and compared,
and any functions hiding information or protecting data are destroyed,
the <code class="docutils literal notranslate"><span class="pre">memcpy_s</span></code> and <code class="docutils literal notranslate"><span class="pre">memset_s</span></code> operations are not recommended.</p>
<p>For details about the POD type, see the appendix.</p>
</div>
<div class="section" id="recommendation-9-1-2-declare-and-initialize-variables-only-when-they-are-used">
<h3>Recommendation 9.1.2 Declare and initialize variables only when they are used.<a class="headerlink" href="#recommendation-9-1-2-declare-and-initialize-variables-only-when-they-are-used" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: It is a common low-level programming error that a variable is
not assigned an initial value before being used. Declaring and
initializing a variable just before using it will prevent this.</p>
<p>If all variables are declared at the beginning of a function before they
are used, their scope covers the entire function, which may lead to the
following problems: * The program may become difficult to understand
and maintain. The definition and use of variables are separated. *
These variables are difficult to initialize properly. At the beginning
of a function, there is often insufficient information for variable
initialization, and a default null value (such as 0) is often assigned
as the initial value. If a variable is used before it is assigned a
valid value, it will also cause errors.</p>
<p>Following the minimization principle of variable scopes and the
principle of proximity declaration will make it easier to read code and
understand variable types and initial values. In particular, use
initialization to replace declaration and then assign values.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad example: Declaration is separated from initialization.</span>
<span class="n">string</span> <span class="n">name</span><span class="p">;</span>        <span class="c1">// The variable is not initialized in the declaration, and a default constructor is called.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s">&quot;zhangsan&quot;</span><span class="p">;</span>  <span class="c1">// An assignment operator is called again. Declaration is separate from definition, which is difficult to understand.</span>

<span class="c1">// Good example: Declaration and initialization are together, and easy to understand.</span>
<span class="n">string</span> <span class="nf">name</span><span class="p">(</span><span class="s">&quot;zhangsan&quot;</span><span class="p">);</span>  <span class="c1">// Invoke a constructor.</span>
</pre></div>
</div>
<blockquote id="expressions-1">
<div><p>Expressions</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="rule-9-2-1-a-variable-cannot-be-referenced-again-if-it-is-contained-in-an-increment-or-decrement-operation-in-an-expression">
<h3>Rule 9.2.1 A variable cannot be referenced again if it is contained in an increment or decrement operation in an expression.<a class="headerlink" href="#rule-9-2-1-a-variable-cannot-be-referenced-again-if-it-is-contained-in-an-increment-or-decrement-operation-in-an-expression" title="Permalink to this headline">¶</a></h3>
<p>In an expression where the increment or decrement operations are
performed on a variable, the variable cannot be referenced again. The
result of a second referencing is not explicitly defined in C++
standards. The results in different compilers or different versions of a
compiler may be different. Therefore, it is recommended that an
undefined operation sequence not be assumed.</p>
<p>Note that the problem of operation sequence cannot be solved by using
parentheses because this is not a priority problem.</p>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Bad: Whether the position of b[i] is before or after the i++ is unclear.</span>
</pre></div>
</div>
<p>The increment or decrement operation should be placed in a single line:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span><span class="o">++</span><span class="p">;</span>            <span class="c1">// Good: i++ is placed in a single line.</span>
</pre></div>
</div>
<p>Function parameter</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>   <span class="c1">// Bad: Whether the increment operation happens for the second parameter is unclear</span>
</pre></div>
</div>
<p>Good example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">i</span><span class="o">++</span><span class="p">;</span>            <span class="c1">// Good: i++ is placed in a single line.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-9-2-2-a-switch-statement-must-have-a-default-branch">
<h3>Rule 9.2.2 A switch statement must have a default branch.<a class="headerlink" href="#rule-9-2-2-a-switch-statement-must-have-a-default-branch" title="Permalink to this headline">¶</a></h3>
<p>In most cases, a switch statement requires a default branch to ensure
that there is a default action when the case tag is missing for a
processed value.</p>
<p>Exception: If the switch condition variables are enumerated and the case
branch covers all values, the default branch is redundant. Because
modern compilers can check which case branches are missing in the switch
statement and provide an advanced warning.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">Color</span> <span class="p">{</span>
    <span class="n">RED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">BLUE</span>
<span class="p">};</span>

<span class="c1">// The switch condition variables are enumerated. Therefore, you do not need to add a default branch.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">RED</span><span class="p">:</span>
        <span class="n">DoRedThing</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">BLUE</span><span class="p">:</span>
        <span class="n">DoBlueThing</span><span class="p">();</span>
        <span class="p">...</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-9-2-1-when-comparing-expressions-follow-the-principle-that-the-left-side-tends-to-change-and-the-right-side-tends-to-remain-unchanged">
<h3>Recommendation 9.2.1 When comparing expressions, follow the principle that the left side tends to change and the right side tends to remain unchanged.<a class="headerlink" href="#recommendation-9-2-1-when-comparing-expressions-follow-the-principle-that-the-left-side-tends-to-change-and-the-right-side-tends-to-remain-unchanged" title="Permalink to this headline">¶</a></h3>
<p>When a variable is compared with a constant, placing the constant on the
left, for example, if (MAX == v), does not comply with standard reading
habits and is more difficult to understand. The constant should be
placed on the right. The expression is written as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">MAX</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
<p>There are special cases: for example, if the expression
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(MIN</span> <span class="pre">&lt;</span> <span class="pre">value</span> <span class="pre">&amp;&amp;</span> <span class="pre">value</span> <span class="pre">&lt;</span> <span class="pre">MAX)</span></code> is used to describe a range, the
first half, as a constant, should be placed on the left.</p>
<p>You do not need to worry about writing ‘==’ as ‘=’ because a compilation
alarm will be generated for <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(value</span> <span class="pre">=</span> <span class="pre">MAX)</span></code> and an error will be
reported by other static check tools. Use these tools to solve such
writing errors and ensure that that code is readable.</p>
</div>
<div class="section" id="recommendation-9-2-2-use-parentheses-to-specify-the-operator-precedence">
<h3>Recommendation 9.2.2 Use parentheses to specify the operator precedence.<a class="headerlink" href="#recommendation-9-2-2-use-parentheses-to-specify-the-operator-precedence" title="Permalink to this headline">¶</a></h3>
<p>Use parentheses to specify the operator precedence. This will prevent
program errors due to the inconsistency between default priority and the
intended design. At the same time, it makes the code clearer and more
readable. However, too many parentheses muddy the code, reducing
readability. The following is a recommendation on their correct usage.</p>
<ul class="simple">
<li><p>For binary and ternary operators, if multiple operators are involved,
parentheses should be used.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  x = a + b + c;        /* The operator does not change, and thus parentheses are not required. */
  x = Foo(a + b, c);     /* The operator does not change, and thus parentheses are not required. */
  x = 1 &lt;&lt; (2 + 3);      /* More than one operator is used and thus parentheses are required. */
  x = a + (b / 5);       /* More than one operator is used and thus parentheses are required. */
  x = (a == b) ? a : (a – b);    /* More than one operator is used and thus parentheses are required. */

Type Casting
</pre></div>
</div>
<hr class="docutils" />
<p>Do not use type branches to customize behaviors. Type branch
customization behavior is prone to errors and is an obvious sign of
attempting to compile C code using C++. This is very inflexible
technology. If you forget to modify all branches when adding a new type
to a compiler, you will not be notified. Use templates and virtual
functions to let the type define itself rather than letting the calling
side determine behavior.</p>
<p>It is recommended that type casting be avoided. We should consider the
data type in the code design instead of overusing type casting to solve
type conflicts. When designing a basic type, consider the following: -
Whether it is unsigned or signed. - Is it suitable for float or double?
- Should you use int8, int16, int32, or int64 bit lengths?</p>
<p>However, we cannot prohibit the use of type casting because the C++
language is a machine-oriented programming language, involving pointer
addresses, and we interact with various third-party or underlying APIs.
Their type design may not be reasonable and type casting tends to occur
in the adaptation process.</p>
<p>Exception: When calling a function, if we do not want to process the
result of the function, first consider whether this is your best choice.
If you do not want to process the return value of the function, cast it
to void.</p>
</div>
<div class="section" id="rule-9-3-1-if-type-casting-is-required-use-the-type-casting-provided-by-the-c-instead-of-the-c-style">
<h3>Rule 9.3.1 If type casting is required, use the type casting provided by the C++ instead of the C style.<a class="headerlink" href="#rule-9-3-1-if-type-casting-is-required-use-the-type-casting-provided-by-the-c-instead-of-the-c-style" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>:</p>
<p>The type casting provided by C++ is more targeted, easy to read, and
more secure than the C style. C++ provides the following types of
casting: - Type casting: 1. <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code>: Used to inherit the
downstream transformation of the system. <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> has the type
check function. Design the base class and derived class to avoid using
dynamic_cast for casting. 2. <code class="docutils literal notranslate"><span class="pre">static_cast</span></code>: Similar to the C style
casting, which can be used to convert a value, or to convert the pointer
or reference of a derived class into a base class pointer or reference.
This casting is often used to eliminate type ambiguity brought on by
multiple inheritance, which is relatively safe. If it is a pure
arithmetic conversion, use the braces as stated in the following text.
3. <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code>: Used to convert irrelevant types.
<code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> forces the compiler to reinterpret the memory of a
certain type of objects into another type, which is an unsafe
conversion. It is recommended that <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> be used as
little as possible. 4. <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>: Used to remove the <code class="docutils literal notranslate"><span class="pre">const</span></code>
attribute of an object so that the object can be modified. You are
advised to use <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> as little as possible.</p>
<ul class="simple">
<li><p>Arithmetic conversion: (Supported by C++ 11 and later versions) If
the type information is not lost, for example, the casting from float
to double, or from int32 to int64, the braces syntax is recommended.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">d</span><span class="p">{</span> <span class="n">someFloat</span> <span class="p">};</span>
<span class="kt">int64_t</span> <span class="n">i</span><span class="p">{</span> <span class="n">someInt32</span> <span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-9-3-1-avoid-using-dynamic-cast">
<h3>Recommendation 9.3.1 Avoid using <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code>.<a class="headerlink" href="#recommendation-9-3-1-avoid-using-dynamic-cast" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> depends on the RTTI of C++ so that the programmer
can identify the type of the object in C++ at run time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> indicates that a problem has occurred in the design
of the base class and derived class.The derived class destroys the
contract of the base class and it is necessary to use
<code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> to convert the class to a subclass for special
processing. In this case, it is more desirable to improve the design
of the class, instead of using <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> to solve the problem.</p></li>
</ol>
</div>
<div class="section" id="recommendation-9-3-2-avoid-using-reinterpret-cast">
<h3>Recommendation 9.3.2 Avoid using <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code>.<a class="headerlink" href="#recommendation-9-3-2-avoid-using-reinterpret-cast" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> is used to convert irrelevant types.
Trying to use <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> to force a type to another type
destroys the security and reliability of the type and is an insecure
casting method. Avoid casting between completely different types.</p>
</div>
<div class="section" id="recommendation-9-3-3-avoid-using-const-cast">
<h3>Recommendation 9.3.3 Avoid using <code class="docutils literal notranslate"><span class="pre">const_cast</span></code>.<a class="headerlink" href="#recommendation-9-3-3-avoid-using-const-cast" title="Permalink to this headline">¶</a></h3>
<p><strong>Note</strong>: The <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> command is used to remove the <code class="docutils literal notranslate"><span class="pre">const</span></code> and
<code class="docutils literal notranslate"><span class="pre">volatile</span></code> properties of an object.</p>
<p>The action of using a pointer or reference after the const_cast
conversion to modify the const property of an object is undefined.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad example:</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>      <span class="c1">// The action is undefined.</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad example:</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">()</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">Fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">Fun</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">// The action is undefined.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="resource-allocation-and-release">
<h2>Resource Allocation and Release<a class="headerlink" href="#resource-allocation-and-release" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rule-9-4-1-when-a-single-object-is-released-delete-is-used-when-an-array-object-is-released-delete-is-used">
<h3>Rule 9.4.1 When a single object is released, delete is used. When an array object is released, delete [] is used.<a class="headerlink" href="#rule-9-4-1-when-a-single-object-is-released-delete-is-used-when-an-array-object-is-released-delete-is-used" title="Permalink to this headline">¶</a></h3>
<p>Note: To delete a single object, use delete; to delete an array object,
use delete []. The reasons are as follows:</p>
<ul class="simple">
<li><p>new: Apply for memory from the system and call the corresponding
constructor to initialize an object.</p></li>
<li><p>new[n]: Apply for memory for n objects and call the constructor n
times for each object to initialize them.</p></li>
<li><p>delete: Call the corresponding destructor first and release the
memory of an object.</p></li>
<li><p>delete[]: Call the corresponding destructor for each object and
release their memory.</p></li>
</ul>
<p>If the usage of new and delete does not match this format, the results
are unknown. For a non-class type, new and delete will not call the
constructor or destructor.</p>
<p>Bad example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_ARRAY_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">numberArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">MAX_ARRAY_SIZE</span><span class="p">];</span>
<span class="p">...</span>
<span class="k">delete</span> <span class="n">numberArray</span><span class="p">;</span>
<span class="n">numberArray</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</div>
<p>Good example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_ARRAY_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">numberArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">MAX_ARRAY_SIZE</span><span class="p">];</span>
<span class="p">...</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">numberArray</span><span class="p">;</span>
<span class="n">numberArray</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-9-4-1-use-the-raii-feature-to-trace-dynamic-allocation">
<h3>Recommendation 9.4.1 Use the RAII feature to trace dynamic allocation.<a class="headerlink" href="#recommendation-9-4-1-use-the-raii-feature-to-trace-dynamic-allocation" title="Permalink to this headline">¶</a></h3>
<p>Note: RAII is an acronym for Resource Acquisition Is Initialization. It
is a simple technology that controls program resources (such as memory,
file handle, network connections, and mutexes) by using the object
lifecycle.</p>
<p>The common practice is as follows: When the object is constructed, the
resource is obtained, and the access to the resource is controlled so
that the resource is always valid in the life cycle of the object.
Finally, the resource is released when the object is destructed. This
approach has two advantages: - We do not need to explicitly release
resources. - The resources required by the object are always valid
throughout the lifecycle of the object. This way, you do not need to
check the validity of the resources, which simplifies logic and improves
efficiency.</p>
<p>In the following example, RAII removes the need for explicit release of
mutex resources.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LockGuard</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">LockGuard</span><span class="p">(</span><span class="k">const</span> <span class="n">LockType</span><span class="o">&amp;</span> <span class="n">lockType</span><span class="p">)</span><span class="o">:</span> <span class="n">lock_</span><span class="p">(</span><span class="n">lockType</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lock_</span><span class="p">.</span><span class="n">Aquire</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">LockGuard</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">lock_</span><span class="p">.</span><span class="n">Relase</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">LockType</span> <span class="n">lock_</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">bool</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">LockGuard</span> <span class="n">lockGuard</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Data operations</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="standard-template-library">
<h2>Standard Template Library<a class="headerlink" href="#standard-template-library" title="Permalink to this headline">¶</a></h2>
<p>The standard template library (STL) varies between products. The
following table lists some basic rules and suggestions for each team.</p>
<div class="section" id="rule-9-5-1-do-not-save-the-pointer-returned-by-c-str-of-std-string">
<h3>Rule 9.5.1 Do not save the pointer returned by c_str () of std::string.<a class="headerlink" href="#rule-9-5-1-do-not-save-the-pointer-returned-by-c-str-of-std-string" title="Permalink to this headline">¶</a></h3>
<p>Note: The C++ standard does not specify that the string::c_str ()
pointer is permanently valid. Therefore, the STL implementation used can
return a temporary storage area and release it quickly when calling
string::c_str (). Therefore, to ensure the portability of the program,
do not save the result of string::c_str (). Instead, call it directly.</p>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Fun1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;demo&quot;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span> <span class="c1">// After the expression ends, the life cycle of name is still in use and the pointer is valid.</span>

    <span class="c1">// If a non-const member function (such as operator[] and begin()) of the string type is invoked and the string is modified,</span>
    <span class="c1">// The text may become unavailable or may not be the original string.</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span><span class="p">;</span>
    <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;2&#39;</span><span class="p">;</span>

    <span class="c1">// When the text pointer is used next time, the string is no longer &quot;demo&quot;.</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Fun2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;demo&quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test</span> <span class="o">=</span> <span class="s">&quot;test&quot;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="n">test</span><span class="p">).</span><span class="n">c_str</span><span class="p">();</span> <span class="c1">// After the expression ends, the temporary object generated by the + operator may be destroyed, and the pointer may be invalid.</span>

    <span class="c1">// When the text pointer is used next time, it no longer points to the valid memory space.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Exception: In rare cases where high performance coding is required , you
can temporarily save the pointer returned by string::c_str() to match
the existing functions which support only the input parameters of the
const char* type. However, you should ensure that the lifecycle of the
string object is longer than that of the saved pointer, and that the
string object is not modified within the lifecycle of the saved pointer.</p>
</div>
<div class="section" id="recommendation-9-5-1-use-std-string-instead-of-char">
<h3>Recommendation 9.5.1 Use std::string instead of char*.<a class="headerlink" href="#recommendation-9-5-1-use-std-string-instead-of-char" title="Permalink to this headline">¶</a></h3>
<p>Note: Using string instead of <code class="docutils literal notranslate"><span class="pre">char*</span></code> has the following advantages: 1.
There is no need to consider the null character ’0’at the end. 2. You
can directly use operators such as <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, and <code class="docutils literal notranslate"><span class="pre">==</span></code>, and other
character and string operation functions. 3. There is no need to
consider memory allocation operations.This helps avoid explicit usage of
<code class="docutils literal notranslate"><span class="pre">new</span></code> and <code class="docutils literal notranslate"><span class="pre">delete</span></code> and the resulting errors.</p>
<p>Note that in some STL implementations, string is based on the
copy-on-write policy, which causes two problems. One is that the
copy-on-write policy of some versions does not implement thread
security, and the program breaks down in multi-threaded environments.
Second, dangling pointers may be caused when a dynamic link library
transfers the string based on the copy-on-write policy, due to the fact
that reference count cannot be reduced when the library is unloaded.
Therefore, it is important to select a reliable STL implementation to
ensure the stability of the program.</p>
<p>Exception: When an API of a system or other third-party library is
called, only <code class="docutils literal notranslate"><span class="pre">char*</span></code> can be used for defined interfaces. However,
before calling the interfaces, you can use string. When calling the
interfaces, you can use <code class="docutils literal notranslate"><span class="pre">string::c_str()</span></code> to obtain the character
pointer. When a character array is allocated as a buffer on the stack,
you can directly define the character array without using string or
containers such as <code class="docutils literal notranslate"><span class="pre">vector&lt;char&gt;</span></code>.</p>
</div>
<div class="section" id="rule-9-5-2-do-not-use-auto-ptr">
<h3>Rule 9.5.2 Do not use auto_ptr.<a class="headerlink" href="#rule-9-5-2-do-not-use-auto-ptr" title="Permalink to this headline">¶</a></h3>
<p>Note: The <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code> in the STL library has an implicit ownership
transfer behavior. The code is as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">);</span>
<span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
</pre></div>
</div>
<p>After the second line of statements is executed, p1 does not point to
the object allocated in line 1 and becomes <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Therefore,
<code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> cannot be placed in any standard containers. This ownership
transfer behavior is not expected. In scenarios where ownership must be
transferred, implicit transfer should not be used. This often requires
the programmer to keep extra attention on code that uses <code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code>,
otherwise access to a null pointer will occur. There are two common
scenarios for using auto_ptr . One is to transfer it as a smart pointer
to outside the function that generates the auto_ptr , and the other is
to use auto_ptr as the RAII management class. Resources are
automatically released when the lifecycle of auto_ptr expires. In the
first scenario, you can use std::shared_ptr instead. In the second
scenario, you can use std::unique_ptr in the C++ 11 standard.
std::unique_ptr is a substitute for std::auto_ptr and supports explicit
ownership transfer.</p>
<p>Exception: Before the C++ 11 standard is widely used, std::auto_ptr can
be used in scenarios where ownership needs to be transferred. However,
it is recommended that std::auto_ptr be encapsulated. The copy
constructor and assignment operator of the encapsulation class should
not be used in a standard container.</p>
</div>
<div class="section" id="recommendation-9-5-2-use-the-new-standard-header-files">
<h3>Recommendation 9.5.2 Use the new standard header files.<a class="headerlink" href="#recommendation-9-5-2-use-the-new-standard-header-files" title="Permalink to this headline">¶</a></h3>
<p>Note: When using the standard header file of C++, use <code class="docutils literal notranslate"><span class="pre">&lt;cstdlib&gt;</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">&lt;stdlib.h&gt;</span></code>.</p>
<blockquote>
<div><p>Usage of const</p>
</div></blockquote>
<hr class="docutils" />
<p>Add the keyword const before the declared variable or parameter
(example: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">foo</span></code>) to prevent the variable from being tampered
with. Add the const qualifier to the function in the class (example:
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{int</span> <span class="pre">Bar</span> <span class="pre">(char</span> <span class="pre">c)</span> <span class="pre">const;}</span> <span class="pre">;</span></code>) to make sure the function
does not modify the status of the class member variable. const
variables, data members, functions, and parameters ensure that the type
detection during compilation is accurate and errors are found as soon as
possible. Therefore, we strongly recommend that const be used in any
possible case. Sometimes it is better to use constexpr from C++ 11 to
define real constants.</p>
</div>
<div class="section" id="rule-9-6-1-for-formal-parameters-of-pointer-and-reference-types-if-the-parameters-do-not-need-to-be-modified-use-const">
<h3>Rule 9.6.1 For formal parameters of pointer and reference types, if the parameters do not need to be modified, use const.<a class="headerlink" href="#rule-9-6-1-for-formal-parameters-of-pointer-and-reference-types-if-the-parameters-do-not-need-to-be-modified-use-const" title="Permalink to this headline">¶</a></h3>
<p>Unchanging values are easier to understand, trace, and analyze.
<code class="docutils literal notranslate"><span class="pre">const</span></code> is used as the default option and is checked during
compilation to make the code more secure and reliable.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">PrintFoo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-9-6-2-for-member-functions-that-do-not-modify-member-variables-use-const">
<h3>Rule 9.6.2 For member functions that do not modify member variables, use const.<a class="headerlink" href="#rule-9-6-2-for-member-functions-that-do-not-modify-member-variables-use-const" title="Permalink to this headline">¶</a></h3>
<p>Declare the member function as <code class="docutils literal notranslate"><span class="pre">const</span></code> whenever possible. The access
function should always be const. So long as the function of a member is
not modified, the function is declared with const. When you need to
modify data members in a virtual function, take all classes in the
inheritance chain into account instead of only focusing on the
implementation of a single class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="c1">// ...</span>

    <span class="kt">int</span> <span class="n">PrintValue</span><span class="p">()</span> <span class="k">const</span> <span class="c1">// const modifies member functions and does not modify member variables.</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">GetValue</span><span class="p">()</span> <span class="k">const</span>  <span class="c1">// const modifies member functions and does not modify member variables.</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-9-6-1-member-variables-that-will-not-be-modified-after-initialization-should-be-defined-as-constants">
<h3>Recommendation 9.6.1 Member variables that will not be modified after initialization should be defined as constants.<a class="headerlink" href="#recommendation-9-6-1-member-variables-that-will-not-be-modified-after-initialization-should-be-defined-as-constants" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="o">:</span> <span class="n">dataLength_</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">dataLength_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<blockquote id="exceptions-1">
<div><p>Exceptions</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-9-7-1-if-the-function-does-not-throw-an-exception-the-declaration-is-noexcept">
<h3>Recommendation 9.7.1 If the function does not throw an exception, the declaration is <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.<a class="headerlink" href="#recommendation-9-7-1-if-the-function-does-not-throw-an-exception-the-declaration-is-noexcept" title="Permalink to this headline">¶</a></h3>
<p><strong>Reasons:</strong> 1. If the function does not throw an exception, the
declaration is <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, which enables the compiler to optimize the
function to the maximum extent, for example, reducing the execution
paths and improving the efficiency of exiting when an error occurs. 2.
For STL containers such as <code class="docutils literal notranslate"><span class="pre">vector</span></code>, to ensure the interface
robustness, if the <code class="docutils literal notranslate"><span class="pre">move</span></code> constructor of saved items is not declared
as <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, the <code class="docutils literal notranslate"><span class="pre">copy</span> <span class="pre">machanism</span></code> instead of the
<code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">machanism</span></code> is used when the items are removed from the
container. This would cause performance loss risks. If the function does
not throw an exception, or a program does not intercept and process an
exception thrown by the function, new <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> keywords can be used
to modify the function, indicating that the function does not throw an
exception or the thrown exception is not intercepted or processed. For
example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">double</span> <span class="n">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>  <span class="c1">// No exceptions are thrown.</span>

<span class="c1">// noexcept can still be used when exceptions may be thrown.</span>
<span class="c1">// The exception of memory exhaustion is not processed. The function is simply declared as noexcept.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MyComputation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">res</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>    <span class="c1">// Exceptions may be thrown.</span>
    <span class="c1">// do something</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">RetType</span> <span class="nf">Function</span><span class="p">(</span><span class="n">Type</span> <span class="n">params</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>   <span class="c1">// Maximized optimization</span>
<span class="n">RetType</span> <span class="nf">Function</span><span class="p">(</span><span class="n">Type</span> <span class="n">params</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>   <span class="c1">// No optimization</span>

<span class="c1">// Declaration as noexcept for the move operation of std::vector is needed.</span>
<span class="k">class</span> <span class="nc">Foo1</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo1</span><span class="p">(</span><span class="n">Foo1</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>  <span class="c1">// no noexcept</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo1</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">;</span>
<span class="n">a1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo1</span><span class="p">());</span>
<span class="n">a1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo1</span><span class="p">());</span> <span class="c1">// The copy constructor is called to enable the container expansion and removal of existing items.</span>

<span class="k">class</span> <span class="nc">Foo2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Foo2</span><span class="p">(</span><span class="n">Foo2</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo2</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">;</span>
<span class="n">a2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo2</span><span class="p">());</span>
<span class="n">a2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Foo2</span><span class="p">());</span> <span class="c1">//Triggers container expansion and invokes the move constructor to move existing elements.</span>
</pre></div>
</div>
<p><strong>Note</strong> The default constructor, destructor, <code class="docutils literal notranslate"><span class="pre">swap</span></code> function, and
<code class="docutils literal notranslate"><span class="pre">move</span></code> operator should not throw an exception.</p>
<blockquote>
<div><p>Templates</p>
</div></blockquote>
<hr class="docutils" />
<p>Template programming allows for extremely flexible interfaces that are
type safe and high performance, enabling reuse of code of different
types but with the same behavior.</p>
<p>The disadvantages of template proramming are as follows:</p>
<ol class="arabic simple">
<li><p>The techniques used in template programming are often obscure to
anyone but language experts. Code that uses templates in complicated
ways is often unreadable, and is hard to debug or maintain.</p></li>
<li><p>Template programming often leads to extremely poor compiler time
error messages: even if an interface is simple, complicated
implementation details become visible when the user does something
wrong.</p></li>
<li><p>If the template is not properly used, the code will be over expanded
during runtime.</p></li>
<li><p>It is difficult to modify or refactor template code. The template
code is expanded in multiple contexts, and it is hard to verify that
the transformation makes sense in all of them.</p></li>
</ol>
<p>Therefore, it is recommended that __ template programming be used only
in a small number of basic components and basic data <a href="#id1"><span class="problematic" id="id2">structure__</span></a>. When
using the template programming, minimize the <strong>complexity as much as
possible, and</strong> avoid exposing the <a href="#id1"><span class="problematic" id="id3">template__</span></a>. It is better to hide
programming as an implementation detail whenever possible, so that
user-facing headers are readable. And you should write sufficiently
detailed comments for code that uses templates.</p>
<blockquote>
<div><p>Macros</p>
</div></blockquote>
<hr class="docutils" />
<p>In the C++ language, it is strongly recommended that complex macros be
used as little as possible. - For constant definitions, use <code class="docutils literal notranslate"><span class="pre">const</span></code> or
<code class="docutils literal notranslate"><span class="pre">enum</span></code> as stated in the preceding sections. - For macro functions, try
to be as simple as possible, comply with the following principles, and
use inline functions and template functions for replacement.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The macro function is not recommended.</span>
<span class="cp">#define SQUARE(a, b) ((a) * (b))</span>

<span class="c1">// Use the template function and inline function as a replacement.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">Square</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>For details about how to use macros, see the related chapters about the
C language specifications. <strong>Exception</strong>: For some common and mature
applications, for example, encapsulation for new and delete, the use of
macros can be retained.</p>
<blockquote>
<div><p>10 Modern C++ Features</p>
</div></blockquote>
<hr class="docutils" />
<p>As the ISO released the C++ 11 language standard in 2011 and released
the C++ 17 in March 2017, the modern C++ (C++ 11/14/17) adds a large
number of new language features and standard libraries that improve
programming efficiency and code quality. This chapter describes some
guidelines for modern C++ use, to avoid language pitfalls.</p>
<blockquote>
<div><p>Code Simplicity and Security Improvement</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-10-1-1-use-auto-properly">
<h3>Recommendation 10.1.1 Use <code class="docutils literal notranslate"><span class="pre">auto</span></code> properly.<a class="headerlink" href="#recommendation-10-1-1-use-auto-properly" title="Permalink to this headline">¶</a></h3>
<p><strong>Reasons</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span></code> can help you avoid writing verbose, repeated type names, and
can also ensure initialization when variables are defined.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">auto</span></code> type deduction rules are complex and need to be read
carefully.</p></li>
<li><p>If using <code class="docutils literal notranslate"><span class="pre">auto</span></code> makes the code clearer, use a specific type of it
and use it only for local variables.</p></li>
</ul>
<p><strong>Example</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Avoid verbose type names.</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

<span class="c1">// Avoid duplicate type names.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{...};</span>
<span class="n">Foo</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">;</span>

<span class="c1">// Ensure that the initialization is successful.</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// The compilation is correct but the variable is not initialized.</span>
<span class="k">auto</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// The compilation failed. Initialization is needed.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">auto</span></code> type deduction may cause the following problems:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>           <span class="c1">// int</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>    <span class="c1">// const int</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ra</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>   <span class="c1">// const int&amp;</span>
<span class="k">auto</span> <span class="n">aa</span> <span class="o">=</span> <span class="n">ca</span><span class="p">;</span>         <span class="c1">// int, const and reference are neglected.</span>
<span class="k">auto</span> <span class="n">ila1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">10</span> <span class="p">};</span>   <span class="c1">// std::initializer_list&lt;int&gt;</span>
<span class="k">auto</span> <span class="n">ila2</span><span class="p">{</span> <span class="mi">10</span> <span class="p">};</span>      <span class="c1">// std::initializer_list&lt;int&gt;</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">ura1</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// int&amp;</span>
<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">ura2</span> <span class="o">=</span> <span class="n">ca</span><span class="p">;</span>     <span class="c1">// const int&amp;</span>
<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">ura3</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1">// int&amp;&amp;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">auto</span> <span class="n">arr1</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>        <span class="c1">// const int*</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">arr2</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">// const int(&amp;)[10]</span>
</pre></div>
</div>
<p>If you do not pay attention to <code class="docutils literal notranslate"><span class="pre">auto</span></code> type deduction and ignore the
reference, hard-to-find performance problems may be created.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// auto deduction changes s1 to std::string in order to copy v[0].</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">auto</span></code> is used to define an interface, such as a constant in a
header file, the type may be changed if the developer has modified the
value.</p>
</div>
<div class="section" id="rule-10-1-1-use-the-keyword-override-when-rewriting-virtual-functions">
<h3>Rule 10.1.1 Use the keyword <code class="docutils literal notranslate"><span class="pre">override</span></code> when rewriting virtual functions.<a class="headerlink" href="#rule-10-1-1-use-the-keyword-override-when-rewriting-virtual-functions" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> The keyword <code class="docutils literal notranslate"><span class="pre">override</span></code> ensures that the function is a
virtual function and an overridden virtual function of the base class.
If the subclass function is different from the base class function
prototype, a compilation alarm is generated. <code class="docutils literal notranslate"><span class="pre">final</span></code> also ensures that
virtual functions are not overridden by subclasses.</p>
<p>If you modify the prototype of a base class virtual function but forget
to modify the virtual function overridden by the subclass, you can find
inconsistency during compilation. You can also avoid forgetting to
modify the overridden function when there are multiple subclasses.</p>
<p><strong>Example</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Foo</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Bar</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Foo</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// Compilation failed: derived::Foo is different from that of the prototype of base::Foo and is not overridden.</span>
    <span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>       <span class="c1">// Compilation successful: derived::Foo overrode base::Foo.</span>
    <span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="k">final</span><span class="p">;</span>   <span class="c1">// Compilation successful: Derived::Foo(int) rewrites Base::Foo(int), and the derived class of Derived cannot override this function.</span>
    <span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>       <span class="c1">// Compilation failed: base::Bar is not a virtual function.</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Summary</strong> 1. When defining the virtual function for the first time
based on the base class, use the keyword <code class="docutils literal notranslate"><span class="pre">virtual</span></code>. 2. When overriding
the virtual function by a subclass in a base class, including
destructors, use the keyword <code class="docutils literal notranslate"><span class="pre">override</span></code> or <code class="docutils literal notranslate"><span class="pre">final</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">virtual</span></code>. 3. For the non-virtual function, do not use <code class="docutils literal notranslate"><span class="pre">virtual</span></code> or
<code class="docutils literal notranslate"><span class="pre">override</span></code>.</p>
</div>
<div class="section" id="rule-10-1-2-use-the-keyword-delete-to-delete-functions">
<h3>Rule: 10.1.2 Use the keyword <code class="docutils literal notranslate"><span class="pre">delete</span></code> to delete functions.<a class="headerlink" href="#rule-10-1-2-use-the-keyword-delete-to-delete-functions" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason</strong> The <code class="docutils literal notranslate"><span class="pre">delete</span></code> keyword is clearer and the application scope
is wider than a class member function that is declared as private and
not implemented.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// Whether the copy structure is deleted or not is unknown because usually only the header file is checked.</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Explicitly delete the copy assignment operator.</span>
    <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">delete</span></code> keyword can also be used to delete non-member functions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Process</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="kt">void</span> <span class="n">Process</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-10-1-3-use-nullptr-instead-of-null-or-0">
<h3>Rule 10.1.3 Use <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> instead of <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code>.<a class="headerlink" href="#rule-10-1-3-use-nullptr-instead-of-null-or-0" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> For a long time, C++ has not had a keyword that represents a
null pointer, which is embarrassing:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NULL ((void *)0)</span>

<span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// Error: void* cannot be automatically converted to char*.</span>

<span class="kt">void</span><span class="p">(</span><span class="n">C</span><span class="o">::*</span><span class="n">pmf</span><span class="p">)()</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">Func</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pmf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Error: void* cannot be automatically converted to the pointer that points to the member function.</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is defined as <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">0L</span></code>, the above problems can be
solved.</p>
<p>Alternatively, use <code class="docutils literal notranslate"><span class="pre">0</span></code> directly in places where null pointers are
required. However, another problem occurs. The code is not clear,
especially when <code class="docutils literal notranslate"><span class="pre">auto</span></code> is used for automatic deduction.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Does Find() return a pointer or an integer?</span>
    <span class="c1">// do something</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Literally <code class="docutils literal notranslate"><span class="pre">0</span></code> is of the <code class="docutils literal notranslate"><span class="pre">int</span></code> type (<code class="docutils literal notranslate"><span class="pre">0L</span></code> is the <code class="docutils literal notranslate"><span class="pre">long</span></code> type).
Therefore, neither <code class="docutils literal notranslate"><span class="pre">NULL</span></code> nor <code class="docutils literal notranslate"><span class="pre">0</span></code> is a pointer type. When a function
of the pointer or integer type is overloaded, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code> calls
only the overloaded pointer function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">// Call F(int) instead of F(int*).</span>
<span class="n">F</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>   <span class="c1">// Call F(int) instead of F(int*).</span>
</pre></div>
</div>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">sizeof(NULL)</span> <span class="pre">==</span> <span class="pre">sizeof(void*)</span></code> does not always make
sense, which is a potential risk.</p>
<p>Summary: If <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">0L</span></code> is directly used, the code is not clear and
type security cannot be ensured. If <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is used, the type security
cannot be ensured. These are all potential risks.</p>
<p><code class="docutils literal notranslate"><span class="pre">nullptr</span></code> has many advantages. It literally represents the null
pointer and makes the code clearer. More to the point, it is no longer
an integer type.</p>
<p><code class="docutils literal notranslate"><span class="pre">nullptr</span></code> is of the <code class="docutils literal notranslate"><span class="pre">std::nullptr_t</span></code> type. <code class="docutils literal notranslate"><span class="pre">std::nullptr_t</span></code> can be
implicitly converted into all original pointer types, so that
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code> can represent a null pointer that points to any type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="n">F</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>   <span class="c1">// Call F(int*).</span>

<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Find() returns a pointer.</span>
    <span class="c1">// do something</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-10-1-4-use-using-instead-of-typedef">
<h3>Rule 10.1.4 Use <code class="docutils literal notranslate"><span class="pre">using</span></code> instead of <code class="docutils literal notranslate"><span class="pre">typedef</span></code>.<a class="headerlink" href="#rule-10-1-4-use-using-instead-of-typedef" title="Permalink to this headline">¶</a></h3>
<p>For versions earlier than <code class="docutils literal notranslate"><span class="pre">C++11</span></code>, you can define the alias of the
type by using <code class="docutils literal notranslate"><span class="pre">typedef</span></code>. No one wants to repeat code like
<code class="docutils literal notranslate"><span class="pre">std::map&lt;uint32_t,</span> <span class="pre">std::vector&lt;int&gt;&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">SomeType</span><span class="p">;</span>
</pre></div>
</div>
<p>Using alias for the type is actually encapsulating the type. This
encapsulation makes the code clearer, and to a large extent avoids the
bulk modification caused by the type change. For versions supporting C++
11 features, <code class="docutils literal notranslate"><span class="pre">using</span></code> is provided to implement <code class="docutils literal notranslate"><span class="pre">alias</span> <span class="pre">declarations</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">SomeType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Compare the two formats:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">Type</span> <span class="n">Alias</span><span class="p">;</span>   <span class="c1">// It cannot be told whether the original Type or Alias is at the front.</span>
<span class="k">using</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">Type</span><span class="p">;</span>   <span class="c1">// The format confirms to the assignment rule. It is easy to understand and helps reduce errors.</span>
</pre></div>
</div>
<p>If this is not enough to prove the advantages of <code class="docutils literal notranslate"><span class="pre">using</span></code>, the alias
template may be a better example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//: Only one line of code is need to define an alias for a template.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span> <span class="n">MyAllocatorVector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="n">MyAllocatorVector</span> <span class="n">data</span><span class="p">;</span>       <span class="c1">// An alias for a template defined with &quot;using&quot;.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">MyAllocatorVector</span> <span class="n">data_</span><span class="p">;</span>   <span class="c1">// Another.</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">typedef</span></code> does not support alias templates and they have to be hacked
in.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// A template is used for packaging typedef. Therefore, a template class is needed.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">MyAllocatorVector</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">MyAllocatorVector</span><span class="o">::</span><span class="n">type</span> <span class="n">data</span><span class="p">;</span>  <span class="c1">// ::type needs to be added when using typedef to define an alias.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">typename</span> <span class="nc">MyAllocatorVector</span><span class="o">::</span><span class="n">type</span> <span class="n">data_</span><span class="p">;</span>  <span class="c1">// For a template class, typename is also needed in addition to ::type.</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-10-1-5-do-not-use-std-move-to-operate-the-const-object">
<h3>Rule 10.1.5 Do not use std::move to operate the const object.<a class="headerlink" href="#rule-10-1-5-do-not-use-std-move-to-operate-the-const-object" title="Permalink to this headline">¶</a></h3>
<p>Literally, <code class="docutils literal notranslate"><span class="pre">std::move</span></code> means moving an object. The const object cannot
be modified and cannot be moved. Therefore, using <code class="docutils literal notranslate"><span class="pre">std::move</span></code> to
operate the const object may confuse code readers. Regarding actual
functions, <code class="docutils literal notranslate"><span class="pre">std::move</span></code> converts an object to the rvalue reference
type. It can convert the const object to the rvalue reference of const.
Because few types define the move constructor and the move assignment
operator that use the const rvalue reference as the parameter, the
actual function of code is often degraded to object copy instead of
object movement, which brings performance loss.</p>
<p><strong>Bad example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">g_string</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">g_stringList</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">&quot;String content&quot;</span><span class="p">;</span>
      <span class="n">g_string</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">myString</span><span class="p">);</span> <span class="c1">// Bad: myString is not moved. Instead, it is copied.</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">anotherString</span> <span class="o">=</span> <span class="s">&quot;Another string content&quot;</span><span class="p">;</span>
      <span class="n">g_stringList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">anotherString</span><span class="p">));</span>    <span class="c1">// Bad: anotherString is not moved. Instead, it is copied.</span>
  <span class="p">}</span>

<span class="n">Smart</span> <span class="n">Pointers</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="rule-10-2-1-use-smart-pointers-instead-of-a-raw-pointer-to-manage-resources">
<h3>Rule 10.2.1 Use smart pointers instead of a raw pointer to manage resources.<a class="headerlink" href="#rule-10-2-1-use-smart-pointers-instead-of-a-raw-pointer-to-manage-resources" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> Avoid resource leakage.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Use</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>               <span class="c1">// Bad: Initializing local pointers with new.</span>
    <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>  <span class="c1">// Good: Guarantee that memory is released.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>                           <span class="c1">// Return and possible leak.</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>                           <span class="c1">// Too late to salvage.</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Exception:</strong> Raw pointers can be used in scenarios requiring high
performance and compatibility.</p>
</div>
<div class="section" id="rule-10-2-2-use-unique-ptr-instead-of-shared-ptr">
<h3>Rule 10.2.2 Use <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> instead of <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>.<a class="headerlink" href="#rule-10-2-2-use-unique-ptr-instead-of-shared-ptr" title="Permalink to this headline">¶</a></h3>
<p><strong>Reasons:</strong> 1. Using <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> a lot has an overhead (atomic
operations on the <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>s reference count have a measurable
cost). 2. Shared ownership in some cases (such as circular dependency)
may create objects that can never be released. 3. Shared ownership can
be an attractive alternative to careful ownership design but it may
obfuscate the design of a system.</p>
</div>
<div class="section" id="rule-10-2-3-use-std-make-unique-instead-of-new-to-create-a-unique-ptr">
<h3>Rule 10.2.3 Use <code class="docutils literal notranslate"><span class="pre">std::make_unique</span></code> instead of <code class="docutils literal notranslate"><span class="pre">new</span></code> to create a <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>.<a class="headerlink" href="#rule-10-2-3-use-std-make-unique-instead-of-new-to-create-a-unique-ptr" title="Permalink to this headline">¶</a></h3>
<p><strong>Reasons:</strong> 1. <code class="docutils literal notranslate"><span class="pre">make_unique</span></code> provides a simpler creation method. 2.
<code class="docutils literal notranslate"><span class="pre">make_unique</span></code> ensures the exception safety of complex expressions.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad: MyClass appears twice, which carries a risk of inconsistency.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="c1">// Good: MyClass appears once and there is no possibility of inconsistency.</span>
<span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Recurrence of types may cause serious problems, and it is difficult to
find them:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// The code compiles fine, but new and delete usage does not match.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">uint8_t</span><span class="p">);</span>
<span class="c1">// No exception safety: The compiler may calculate parameters in the following order:</span>
<span class="c1">// 1. Allocate the memory of Foo.</span>
<span class="c1">// 2. Construct Foo.</span>
<span class="c1">// 3. Call Bar.</span>
<span class="c1">// 4. Construct unique_ptr&lt;Foo&gt;.</span>
<span class="c1">// If Bar throws an exception, Foo is not destroyed and a memory leak occurs.</span>
<span class="n">F</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">()),</span> <span class="n">Bar</span><span class="p">());</span>

<span class="c1">// Exception safety: Calling of function is not interrupted.</span>
<span class="n">F</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">Bar</span><span class="p">());</span>
</pre></div>
</div>
<p><strong>Exception:</strong> <code class="docutils literal notranslate"><span class="pre">std::make_unique</span></code> does not support user-defined
<code class="docutils literal notranslate"><span class="pre">deleter</span></code>. In the scenario where the <code class="docutils literal notranslate"><span class="pre">deleter</span></code> needs to be
customized, it is recommended that <code class="docutils literal notranslate"><span class="pre">make_unique</span></code> be implemented in the
customized version’s own namespace. Using <code class="docutils literal notranslate"><span class="pre">new</span></code> to create
<code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> with the user-defined <code class="docutils literal notranslate"><span class="pre">deleter</span></code> is the last choice.</p>
</div>
<div class="section" id="rule-10-2-4-create-shared-ptr-by-using-std-make-shared-instead-of-new">
<h3>Rule 10.2.4 Create <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> by using <code class="docutils literal notranslate"><span class="pre">std::make_shared</span></code> instead of <code class="docutils literal notranslate"><span class="pre">new</span></code>.<a class="headerlink" href="#rule-10-2-4-create-shared-ptr-by-using-std-make-shared-instead-of-new" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> In addition to the consistency factor similar to that in
<code class="docutils literal notranslate"><span class="pre">std::make_unique</span></code> when using <code class="docutils literal notranslate"><span class="pre">std::make_shared</span></code>, performance is
also a factor to consider. <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> manages two entities: *
Control block (storing reference count, <code class="docutils literal notranslate"><span class="pre">deleter</span></code>, etc.) * Managed
objects</p>
<p>When <code class="docutils literal notranslate"><span class="pre">std::make_shared</span></code> creates <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>, it allocates
sufficient memory for storing control blocks and managed objects on the
heap at a time. When <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;MyClass&gt;(new</span> <span class="pre">MyClass)</span></code>is used
to create a <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>, not only does <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">MyClass</span></code> trigger
heap allocation, but the constructor function of <code class="docutils literal notranslate"><span class="pre">std::shard_ptr</span></code>
triggers a second heap allocation, resulting in extra overhead.</p>
<p><strong>Exception:</strong> Similar to <code class="docutils literal notranslate"><span class="pre">std::make_unique</span></code>, <code class="docutils literal notranslate"><span class="pre">std::make_shared</span></code>
does not support <code class="docutils literal notranslate"><span class="pre">deleter</span></code> customization.</p>
<blockquote>
<div><p>Lambda</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-10-3-1-use-lambda-to-capture-local-variables-or-write-local-functions-when-normal-functions-do-not-work">
<h3>Recommendation 10.3.1 Use <code class="docutils literal notranslate"><span class="pre">lambda</span></code> to capture local variables or write local functions when normal functions do not work.<a class="headerlink" href="#recommendation-10-3-1-use-lambda-to-capture-local-variables-or-write-local-functions-when-normal-functions-do-not-work" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> Functions cannot capture local variables or be declared at
local scope. If you need those things, choose <code class="docutils literal notranslate"><span class="pre">lambda</span></code> instead of
handwritten <code class="docutils literal notranslate"><span class="pre">functor</span></code>. On the other hand, <code class="docutils literal notranslate"><span class="pre">lambda</span></code> and <code class="docutils literal notranslate"><span class="pre">functor</span></code>
objects do not support overloading. If overloading is required, use a
function. If both <code class="docutils literal notranslate"><span class="pre">lambda</span></code> and functions work, a function is
preferred. Use the simplest tool.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Write a function that accepts only an int or string.</span>
<span class="c1">// -- Overloading is more natural.</span>
<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>

<span class="c1">// The local state needs to be captured or appear in the statement or expression range.</span>
<span class="c1">// -- A lambda is more natural.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Work</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">LotsOfWork</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">taskNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">taskNum</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="o">++</span><span class="n">taskNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">Run</span><span class="p">([</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">]</span> <span class="p">{...});</span>
<span class="p">}</span>
<span class="n">pool</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="rule-10-3-1-avoid-capturing-by-reference-in-lambdas-that-will-not-be-used-locally">
<h3>Rule 10.3.1 Avoid capturing by reference in lambdas that will not be used locally.<a class="headerlink" href="#rule-10-3-1-avoid-capturing-by-reference-in-lambdas-that-will-not-be-used-locally" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> Using <code class="docutils literal notranslate"><span class="pre">lambdas</span></code> at a “nonlocal” scope includes returning,
storing on the heap, and passing to another thread. Local pointers and
references should not outlive their scope. Capturing by reference in
<code class="docutils literal notranslate"><span class="pre">lambdas</span></code> indicates storing a reference to a local object. If this
leads to a reference that exceeds the lifecycle of a local variable,
capturing by reference should not be used.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="c1">// Capture a reference to a local variable.</span>
    <span class="c1">// After the function returns results, local no longer exists,</span>
    <span class="c1">// Process() call will have undefined behavior.</span>
    <span class="n">threadPool</span><span class="p">.</span><span class="n">QueueWork</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">Process</span><span class="p">(</span><span class="n">local</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// Good</span>
<span class="kt">void</span> <span class="nf">Foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="c1">// Capture a copy of local.</span>
    <span class="c1">// Since a copy of local is made, it will be always available for the call.</span>
    <span class="n">threadPool</span><span class="p">.</span><span class="n">QueueWork</span><span class="p">([</span><span class="o">=</span><span class="p">]{</span> <span class="n">Process</span><span class="p">(</span><span class="n">local</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-10-3-2-all-variables-are-explicitly-captured-if-this-is-captured">
<h3>Recommendation 10.3.2 All variables are explicitly captured if <code class="docutils literal notranslate"><span class="pre">this</span></code> is captured.<a class="headerlink" href="#recommendation-10-3-2-all-variables-are-explicitly-captured-if-this-is-captured" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> The <code class="docutils literal notranslate"><span class="pre">[=]</span></code> in the member function seems to indicate
capturing by value but actually it is capturing data members by
reference because it captures the invisible <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer by value.
Generally, it is recommended that capturing by reference be avoided. If
it is necessary to do so, write <code class="docutils literal notranslate"><span class="pre">this</span></code> explicitly.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Foo</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">Lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]()</span> <span class="p">{</span> <span class="n">Use</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data_</span><span class="p">);</span> <span class="p">};</span>   <span class="c1">// Bad: It looks like we are copying or capturing by value but member variables are actually captured by reference.</span>

        <span class="n">data_</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
        <span class="n">Lambda</span><span class="p">();</span> <span class="c1">// Call use(42);</span>
        <span class="n">data_</span> <span class="o">=</span> <span class="mi">43</span><span class="p">;</span>
        <span class="n">Lambda</span><span class="p">();</span> <span class="c1">// Call use(43);</span>

        <span class="k">auto</span> <span class="n">Lambda2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="k">this</span><span class="p">]()</span> <span class="p">{</span> <span class="n">Use</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data_</span><span class="p">);</span> <span class="p">};</span> <span class="c1">// Good: the most explicit and least confusing method.</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">data_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="recommendation-10-3-3-avoid-default-capture-modes">
<h3>Recommendation 10.3.3 Avoid default capture modes.<a class="headerlink" href="#recommendation-10-3-3-avoid-default-capture-modes" title="Permalink to this headline">¶</a></h3>
<p><strong>Reason:</strong> The lambda expression provides two default capture modes:
by-reference (&amp;) and by-value (=). By default, the “by-reference”
capture mode will implicitly capture the reference of all local
variables, which will easily lead to dangling references. By contrast,
explicitly writing variables that need to be captured can make it easier
to check the lifecycle of an object and reduce the possibility of making
a mistake. By default, the “by-value” capture mode will implicitly
capture this pointer, and it is difficult to find out which variables
the lambda function depends on. If a static variable exists, the reader
mistakenly considers that the lambda has copied a static variable.
Therefore, it is required to clearly state the variables that lambda
needs to capture, instead of using the default capture mode.</p>
<p><strong>Bad example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">addend</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">baseValue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">]()</span> <span class="p">{</span>  <span class="c1">// Only addend is actually copied.</span>
        <span class="o">++</span><span class="n">baseValue</span><span class="p">;</span>    <span class="c1">// The modification will affect the value of the static variable.</span>
        <span class="k">return</span> <span class="n">baseValue</span> <span class="o">+</span> <span class="n">addend</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Good example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">addend</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">baseValue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">addend</span><span class="p">,</span> <span class="n">baseValue</span> <span class="o">=</span> <span class="n">baseValue</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span>  <span class="c1">// Uses the C++14 capture initialization to copy a variable.</span>
        <span class="o">++</span><span class="n">baseValue</span><span class="p">;</span>    <span class="c1">// Modifying the copy of a static variable does not affect the value of the static variable.</span>
        <span class="k">return</span> <span class="n">baseValue</span> <span class="o">+</span> <span class="n">addend</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Reference: Effective Modern C++: Item 31: Avoid default capture modes.</p>
<blockquote>
<div><p>Interfaces</p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="recommendation-10-4-1-use-t-or-t-arguments-instead-of-a-smart-pointer-in-scenarios-where-ownership-is-not-involved">
<h3>Recommendation 10.4.1 Use <code class="docutils literal notranslate"><span class="pre">T*</span></code> or <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> arguments instead of a smart pointer in scenarios where ownership is not involved.<a class="headerlink" href="#recommendation-10-4-1-use-t-or-t-arguments-instead-of-a-smart-pointer-in-scenarios-where-ownership-is-not-involved" title="Permalink to this headline">¶</a></h3>
<p><strong>Reasons:</strong> 1. Passing a smart pointer to transfer or share ownership
should only be used when the ownership mechanism is explicitly required.
2. Passing a smart pointer (for example, passing the <code class="docutils literal notranslate"><span class="pre">this</span></code> smart
pointer) restricts the use of a function to callers using smart
pointers. 3. Passing a shared smart pointer adds a runtime performance
cost.</p>
<p><strong>Example:</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Accept any int*.</span>
<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Accept only integers for which you want to transfer ownership.</span>
<span class="kt">void</span> <span class="nf">G</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Accept only integers for which you want to share ownership.</span>
<span class="kt">void</span> <span class="nf">G</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Does not need to change the ownership but requires ownership of the caller.</span>
<span class="kt">void</span> <span class="nf">H</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">);</span>

<span class="c1">// Accept any int.</span>
<span class="kt">void</span> <span class="nf">H</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>

<span class="c1">// Bad</span>
<span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">Use</span><span class="p">(</span><span class="o">*</span><span class="n">w</span><span class="p">);</span> <span class="c1">// When only w is used, lifecycle management is not required.</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Harmony</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Arul.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/docs-en/contribute/OpenHarmony-cpp-coding-style-guide.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>